<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buddyliko - Your Buddy in transformations</title>
    
    <link rel="icon" type="image/svg+xml" href="/assets/logo-icon.svg">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }
        .app-container {
            display: flex;
            height: 100vh;
        }
        
        /* Responsive Sidebar */
        .sidebar {
            width: 350px;
            min-width: 280px;
            background: white;
            border-right: 2px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }
        
        .sidebar.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            overflow: hidden;
            border: none;
        }
        
        /* Toggle button for sidebar */
        .sidebar-toggle {
            position: fixed;
            left: 10px;
            bottom: 10px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #00BCD4 0%, #3F51B5 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        
        .sidebar-toggle:hover {
            background: linear-gradient(135deg, #00ACC1 0%, #3949AB 100%);
            transform: scale(1.1);
        }
        
        .sidebar-header {
            padding: 8px 12px 8px;
            background: linear-gradient(135deg, #29D6EC 0%, #6573C3 100%);
            color: white;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .sidebar-footer {
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            background: #fafafa;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00BCD4 0%, #3F51B5 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }
        
        .user-details {
            flex: 1;
            font-size: 13px;
        }
        
        .user-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }
        
        .user-email {
            color: #666;
            font-size: 11px;
        }
        
        .btn-logout {
            width: 100%;
            padding: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }
        
        .btn-logout:hover {
            border-color: #00BCD4;
            color: #00BCD4;
            background: #f8f9ff;
        }
        .main-canvas {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Important for flex shrinking */
        }
        
        /* Responsive Toolbar */
        .toolbar {
            background: white;
            border-bottom: 2px solid #ddd;
            padding: 12px 15px;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            overflow-x: auto;
        }
        
        .canvas-area {
            flex: 1;
            background: #fafafa;
            overflow: auto;
            padding: 20px;
            position: relative;
        }
        
        /* Responsive Properties Panel */
        .properties-panel {
            width: 350px;
            min-width: 280px;
            background: white;
            border-left: 2px solid #ddd;
            overflow-y: auto;
            padding: 20px;
        }
        
        /* UNIFORM BUTTON SIZES */
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            min-width: 140px;        /* ALL BUTTONS SAME WIDTH */
            height: 42px;            /* ALL BUTTONS SAME HEIGHT */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;          /* Don't shrink */
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary { 
            background: #00BCD4; 
            color: white; 
        }
        .btn-primary:hover:not(:disabled) { 
            background: #5568d3; 
        }
        
        .btn-secondary { 
            background: #e0e0e0; 
            color: #333; 
        }
        .btn-secondary:hover:not(:disabled) { 
            background: #d0d0d0; 
        }
        
        .btn-success { 
            background: #4caf50; 
            color: white; 
        }
        .btn-success:hover:not(:disabled) { 
            background: #43a047; 
        }
        
        .btn-danger { 
            background: #f44336; 
            color: white; 
        }
        .btn-danger:hover:not(:disabled) { 
            background: #e53935; 
        }
        
        /* Full width buttons (sidebar) */
        .btn-full {
            width: 100%;
            min-width: 100%;
            margin-bottom: 10px;
        }
        
        /* Uniform input fields */
        input[type="text"], select, textarea {
            height: 42px;            /* SAME AS BUTTONS */
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 13px;
            transition: border-color 0.2s;
        }
        
        input[type="text"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #00BCD4;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }
        
        /* Search input specific */
        .search-input {
            width: 280px;
            font-family: 'Courier New', monospace;
        }
        
        .field-box {
            padding: 10px;
            margin: 8px 0;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            /* Word wrap and dynamic height */
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            min-height: auto;
            height: auto;
        }

        /* Node action buttons ‚Äî hidden by default, visible on hover */
        .field-box-actions {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            gap: 3px;
            z-index: 10;
        }
        .field-box:hover .field-box-actions {
            display: flex;
        }
        .field-action-btn {
            width: 22px;
            height: 22px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.85;
            transition: all 0.15s;
        }
        .field-action-btn:hover { opacity: 1; transform: scale(1.15); }
        .field-action-btn.edit  { background: #e3f2fd; color: #1565c0; }
        .field-action-btn.delete { background: #ffebee; color: #c62828; }
        
        /* Removed resize handle from cells */
        .field-box:hover {
            border-color: #00BCD4;
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(102,126,234,0.2);
        }
        .field-box.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .field-box.selected {
            border-color: #4caf50;
            background: #e8f5e9;
            border-width: 3px;
        }
        .field-box.required {
            border-left: 4px solid #4caf50;
        }
        .field-box.calculated {
            background: #fff3cd;
            border-color: #ffc107;
        }
        
        .field-box.highlighted {
            background: #fffacd !important;  /* Light yellow */
            border-color: #ffd700 !important;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            animation: pulse-highlight 1s ease-in-out;
        }
        
        @keyframes pulse-highlight {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
        }
        
        .field-name {
            font-weight: 700;
            font-size: 13px;
            margin-bottom: 4px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }
        .field-business {
            font-size: 11px;
            color: #666;
            font-style: italic;
            margin-bottom: 4px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .field-meta {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .field-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            background: #e0e0e0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }
        
        .canvas-columns {
            display: flex;
            gap: 40px;
            position: relative;
            height: 100%;
            justify-content: space-between;
        }
        .canvas-column {
            flex: 1;
            min-width: 300px;
            max-height: 100%;
            overflow-y: auto;
            overflow-x: visible;      /* VISIBLE per mostrare handles! */
            position: relative;
        }
        
        /* Input handle - RIGHT side, slightly UP - MORE VISIBLE */
        .resize-handle-input {
            position: absolute;
            right: -16px;              /* Closer to edge */
            top: calc(50% - 50px);     /* Slightly UP */
            width: 16px;               /* Wider */
            height: 60px;              /* Taller */
            background: #00BCD4;       /* Blue by default */
            border: 2px solid white;
            border-radius: 4px;
            cursor: ew-resize;
            z-index: 500;              /* Higher z-index */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            user-select: none;
            transition: all 0.15s;
        }
        
        .resize-handle-input:hover {
            background: #5568d3;
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.5);
        }
        
        /* Output handle - LEFT side, slightly DOWN - MORE VISIBLE */
        .resize-handle-output {
            position: absolute;
            left: -16px;               /* Closer to edge */
            top: calc(50% + 50px);     /* Slightly DOWN */
            width: 16px;               /* Wider */
            height: 60px;              /* Taller */
            background: #00BCD4;       /* Blue by default */
            border: 2px solid white;
            border-radius: 4px;
            cursor: ew-resize;
            z-index: 500;              /* Higher z-index */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            user-select: none;
            transition: all 0.15s;
        }
        
        .resize-handle-output:hover {
            background: #5568d3;
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.5);
        }
        .canvas-column h3 {
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: default;
            user-select: none;
        }
        
        /* Draggable area on right edge of headers */
        .canvas-column h3::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 20px;
            cursor: ew-resize;
            background: linear-gradient(to left, rgba(102, 126, 234, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .canvas-column h3:hover::after {
            opacity: 1;
        }
        
        svg.connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }
        svg.connections path {
            pointer-events: stroke;
            cursor: pointer;
        }
        .connection-line {
            fill: none;
            stroke: #00BCD4;
            stroke-width: 3;
            transition: none; /* Remove transition to avoid lag during scroll */
        }
        .connection-line:hover {
            stroke: #4caf50;
            stroke-width: 4;
        }
        .connection-line.selected {
            stroke: #f44336;
            stroke-width: 4;
            stroke-dasharray: 5,5;
            animation: dash 0.5s linear infinite;
        }
        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }
        .connection-arrow {
            fill: #00BCD4;
        }
        
        /* Hover Popup */
        .hover-popup {
            position: fixed;
            background: white;
            border: 2px solid black;
            padding: 12px;
            border-radius: 4px;
            z-index: 2000;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            animation: fadeInPopup 0.2s;
        }
        @keyframes fadeInPopup {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .hover-popup-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        .hover-popup-code {
            background: black;
            color: white;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
            border-radius: 3px;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .hover-popup-highlight {
            background: white;
            color: black;
            padding: 2px 4px;
            font-weight: bold;
            border-radius: 2px;
            display: inline;
        }
        
        /* Formula Editor */
        .formula-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        .formula-editor {
            background: white;
            border-radius: 8px;
            width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .formula-editor-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
        }
        .formula-editor-header h3 {
            margin: 0;
            color: #333;
        }
        .formula-editor-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }
        .formula-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
        }
        .formula-textarea:focus {
            outline: none;
            border-color: #00BCD4;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }
        .operator-buttons {
            margin-top: 15px;
        }
        .operator-buttons-label {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
        }
        .operator-buttons-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .operator-btn {
            padding: 6px 12px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }
        .operator-btn:hover {
            background: #00BCD4;
            color: white;
            border-color: #00BCD4;
        }
        .formula-editor-footer {
            padding: 20px;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .status-message {
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        .status-success { background: #d4edda; color: #155724; }
        .status-error { background: #f8d7da; color: #721c24; }
        
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .modal {
            background: white;
            border-radius: 12px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
        }
        .upload-area:hover {
            border-color: #00BCD4;
            background: #f5f5ff;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            font-size: 13px;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #eee;
            margin-bottom: 15px;
        }
        .tab {
            padding: 10px 16px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
        }
        .tab.active {
            border-bottom-color: #00BCD4;
            color: #00BCD4;
        }
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }
        .connection-list-item {
            padding: 10px;
            margin: 5px 0;
            background: #f9f9f9;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .connection-list-item:hover {
            background: #f0f0f0;
        }
        .connection-list-item.selected {
            border-color: #00BCD4;
            background: #e3f2fd;
        }
        
        /* ========================================
           RESPONSIVE DESIGN
           ======================================== */
        
        /* Large tablets and smaller desktops */
        @media (max-width: 1200px) {
            .btn {
                min-width: 130px;
                font-size: 12px;
            }
            .search-input {
                width: 220px;
            }
        }
        
        /* Tablets */
        @media (max-width: 1024px) {
            .sidebar {
                width: 280px;
                min-width: 250px;
            }
            .properties-panel {
                width: 280px;
                min-width: 250px;
            }
            .btn {
                min-width: 110px;
                font-size: 12px;
                padding: 8px 12px;
                height: 38px;
            }
            input[type="text"], select {
                height: 38px;
            }
            .toolbar {
                gap: 6px;
                padding: 10px 12px;
            }
            .search-input {
                width: 180px;
            }
        }
        
        /* Mobile landscape and smaller tablets */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                max-height: 35vh;
                border-right: none;
                border-bottom: 2px solid #ddd;
            }
            .properties-panel {
                width: 100%;
                max-height: 35vh;
                border-left: none;
                border-top: 2px solid #ddd;
            }
            .toolbar {
                flex-wrap: wrap;
                justify-content: flex-start;
                padding: 8px;
            }
            .btn {
                flex: 1 1 calc(50% - 4px); /* 2 buttons per row */
                min-width: calc(50% - 4px);
                max-width: calc(50% - 4px);
                height: 40px;
            }
            .search-input {
                flex: 1 1 100%;
                width: 100%;
                margin-bottom: 4px;
            }
            input[type="text"]:not(.search-input) {
                flex: 1 1 100%;
                width: 100%;
                margin-bottom: 4px;
            }
            .canvas-area {
                padding: 10px;
            }
        }
        
        /* Mobile portrait */
        @media (max-width: 480px) {
            .sidebar-header h2 {
                font-size: 18px;
            }
            .btn {
                flex: 1 1 100%; /* 1 button per row */
                min-width: 100%;
                max-width: 100%;
            }
            .field-box {
                font-size: 12px;
                padding: 8px;
            }
            .toolbar {
                padding: 6px;
            }
        }
        
        /* Extra small phones */
        @media (max-width: 360px) {
            .sidebar-header {
                padding: 15px;
            }
            .sidebar-header h2 {
                font-size: 16px;
            }
            .btn {
                font-size: 11px;
                padding: 6px 10px;
            }
        }
        
        /* High DPI screens (Retina) */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .field-box {
                border-width: 1.5px;
            }
            .btn {
                border-width: 0;
            }
        }
        
        /* Landscape orientation on mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .sidebar, .properties-panel {
                max-height: none;
                height: auto;
            }
            .sidebar-content {
                max-height: 60vh;
            }
        }

        /* ===== NODE IMPORT / EDIT / DELETE FEATURES ===== */
        
        /* "+" button in column headers */
        .col-import-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: #ff9800;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            line-height: 1;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            flex-shrink: 0;
        }
        .col-import-btn:hover {
            background: #f57c00;
            transform: scale(1.12);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Node import modal */
        .node-import-modal {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 480px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .node-import-modal h3 {
            margin: 0;
            font-size: 16px;
        }

        /* Draggable node-bundle */
        .node-bundle {
            position: fixed;
            z-index: 9000;
            background: white;
            border: 2px dashed #00BCD4;
            border-radius: 8px;
            padding: 10px 14px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
            cursor: grab;
            user-select: none;
            max-width: 280px;
            min-width: 180px;
        }
        .node-bundle:active { cursor: grabbing; }
        .node-bundle-title {
            font-size: 12px;
            font-weight: 700;
            color: #00BCD4;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .node-bundle-count {
            background: #00BCD4;
            color: white;
            border-radius: 10px;
            padding: 1px 7px;
            font-size: 11px;
        }
        .node-bundle-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 11px;
            max-height: 120px;
            overflow-y: auto;
        }
        .node-bundle-list li {
            padding: 2px 0;
            border-bottom: 1px solid #f0f0f0;
            color: #333;
        }
        .node-bundle-drop-hint {
            margin-top: 8px;
            font-size: 10px;
            color: #888;
            text-align: center;
            font-style: italic;
        }

        /* Drop zone highlight on field-box */
        .field-box.bundle-drop-target {
            border-color: #00BCD4 !important;
            border-style: dashed !important;
            background: #e0f7fa !important;
            box-shadow: 0 0 12px rgba(0,188,212,0.4);
        }
        
        /* Field context menu */
        .field-context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.18);
            z-index: 8000;
            min-width: 160px;
            overflow: hidden;
        }
        .field-context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s;
        }
        .field-context-menu-item:hover {
            background: #f5f5f5;
        }
        .field-context-menu-item.danger {
            color: #f44336;
        }
        .field-context-menu-item.danger:hover {
            background: #ffebee;
        }
        .field-context-menu-separator {
            height: 1px;
            background: #eee;
            margin: 2px 0;
        }

        /* Node edit modal */
        .node-edit-modal {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 420px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .node-edit-modal h3 {
            margin: 0;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <!-- Authentication Check - BLOCKING VERSION -->
    <div id="auth-check" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #00BCD4 0%, #3F51B5 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999999;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    ">
        <div style="text-align: center;">
            <div style="
                width: 50px;
                height: 50px;
                border: 4px solid rgba(255,255,255,0.3);
                border-top-color: white;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 0 auto 20px;
            "></div>
            <style>
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
            </style>
            <h2 style="font-size: 24px; margin-bottom: 10px;">Verifying Authentication...</h2>
            <p style="font-size: 14px; opacity: 0.9;">Please wait</p>
        </div>
    </div>
    
    <script>
        // BLOCKING authentication check
        (async function() {
            const API_BASE = 'http://localhost:8080';
            const authCheckDiv = document.getElementById('auth-check');
            
            try {
                console.log('üîê Checking authentication...');
                
                // Check if auth is enabled
                const statusResponse = await fetch(`${API_BASE}/api/auth/status`);
                
                if (!statusResponse.ok) {
                    console.error('‚ùå Failed to check auth status');
                    authCheckDiv.remove();
                    return;
                }
                
                const status = await statusResponse.json();
                console.log('Auth status:', status);
                
                if (status.enabled) {
                    console.log('üîê Auth is ENABLED');
                    
                    // Auth is enabled, verify token
                    const token = localStorage.getItem('datamapper_token');
                    
                    if (!token) {
                        console.log('‚ùå No token found, redirecting to login...');
                        window.location.href = '/login.html';
                        return;
                    }
                    
                    console.log('üîë Token found, verifying...');
                    
                    // Verify token is valid
                    const meResponse = await fetch(`${API_BASE}/api/auth/me`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (!meResponse.ok) {
                        console.log('‚ùå Token invalid, redirecting to login...');
                        localStorage.removeItem('datamapper_token');
                        localStorage.removeItem('datamapper_user');
                        window.location.href = '/login.html';
                        return;
                    }
                    
                    const userData = await meResponse.json();
                    console.log('‚úÖ Authenticated as:', userData);
                    
                    // Token valid, remove blocking overlay and continue
                    authCheckDiv.remove();
                } else {
                    console.log('üîì Auth is DISABLED, continuing...');
                    // Auth disabled, remove blocking overlay and continue
                    authCheckDiv.remove();
                }
                
            } catch (e) {
                console.error('‚ö†Ô∏è Auth check failed:', e);
                // On error, remove overlay and continue anyway
                authCheckDiv.remove();
            }
        })();
        
        // Add logout functionality
        function logout() {
            localStorage.removeItem('datamapper_token');
            localStorage.removeItem('datamapper_user');
            window.location.href = '/login.html';
        }
        
        // Get auth token for API calls
        function getAuthHeaders() {
            const token = localStorage.getItem('datamapper_token');
            if (token) {
                return { 'Authorization': `Bearer ${token}` };
            }
            return {};
        }
    </script>
    
    <div id="root"></div>
    
    <script>
        const { useState, useEffect, useRef } = React;
        const API_URL = 'http://localhost:8080/api';
        
        // Hover Popup Component
        function HoverPopup({ popup, setPopupPinned, setHoverPopup }) {
            if (!popup) return null;
            
            // Render line with character-level highlighting
            const renderInputLine = (line, idx) => {
                const isHighlighted = idx === popup.highlightIndex;
                
                if (isHighlighted && popup.highlightChar) {
                    // Character-level highlighting for IDOC flat files
                    const { start, end } = popup.highlightChar;
                    const before = line.substring(0, start);
                    const highlighted = line.substring(start, end);
                    const after = line.substring(end);
                    
                    return React.createElement('div', { 
                        key: idx,
                        style: { 
                            background: '#e0e0e0',  // GRIGIO CHIARO
                            color: 'black',          // TESTO NERO
                            padding: '2px 4px',
                            fontFamily: 'monospace',
                            whiteSpace: 'pre',
                            fontSize: '11px'
                        }
                    },
                        React.createElement('span', { style: { color: 'black' } }, before),
                        React.createElement('span', { 
                            style: { 
                                background: 'black',  // VALORE: NERO
                                color: 'white',       // TESTO BIANCO
                                fontWeight: 'bold',
                                padding: '0 2px'
                            }
                        }, highlighted),
                        React.createElement('span', { style: { color: 'black' } }, after)
                    );
                } else if (isHighlighted) {
                    // LINE-LEVEL HIGHLIGHTING for XML with advanced coloring
                    // Check if line contains XML tags
                    const isXMLLine = line.trim().includes('<') && line.trim().includes('>');
                    
                    if (isXMLLine) {
                        // Parse XML line with colorization:
                        // 1. Opening/Closing tags: dark gray background, white text
                        // 2. Final values: black background, green text
                        // 3. Subtags: black background, yellow text
                        
                        const parts = [];
                        let remaining = line;
                        let key = 0;
                        
                        // Regex to match XML tags and content
                        const xmlRegex = /(<[^>]+>)|([^<>]+)/g;
                        let match;
                        
                        while ((match = xmlRegex.exec(line)) !== null) {
                            if (match[1]) {
                                // It's a tag: <tag> or </tag>
                                const tagContent = match[1];
                                
                                parts.push(
                                    React.createElement('span', {
                                        key: key++,
                                        style: {
                                            background: '#555',  // DARK GRAY for tags
                                            color: 'white',      // WHITE text
                                            padding: '0 2px',
                                            fontWeight: 'normal'
                                        }
                                    }, tagContent)
                                );
                            } else if (match[2]) {
                                // It's content between tags
                                const content = match[2];
                                
                                // Check if content contains nested tags (subtag) or is final value
                                const hasNestedTags = content.includes('<');
                                const trimmedContent = content.trim();
                                
                                if (trimmedContent.length > 0) {
                                    if (hasNestedTags) {
                                        // Content with subtags - YELLOW
                                        parts.push(
                                            React.createElement('span', {
                                                key: key++,
                                                style: {
                                                    background: 'black',
                                                    color: 'yellow',
                                                    fontWeight: 'bold'
                                                }
                                            }, content)
                                        );
                                    } else {
                                        // Final value - GREEN
                                        parts.push(
                                            React.createElement('span', {
                                                key: key++,
                                                style: {
                                                    background: 'black',
                                                    color: '#0f0',  // BRIGHT GREEN for value
                                                    fontWeight: 'bold',
                                                    padding: '0 2px'
                                                }
                                            }, content)
                                        );
                                    }
                                } else {
                                    // Whitespace
                                    parts.push(content);
                                }
                            }
                        }
                        
                        return React.createElement('div', {
                            key: idx,
                            style: {
                                background: 'black',
                                padding: '2px 4px',
                                fontFamily: 'monospace',
                                whiteSpace: 'pre',
                                fontSize: '11px'
                            }
                        }, ...parts);
                        
                    } else {
                        // Non-XML line - simple white on black
                        return React.createElement('div', { 
                            key: idx,
                            style: { 
                                background: 'black',
                                color: 'white',
                                padding: '2px 4px',
                                fontFamily: 'monospace',
                                whiteSpace: 'pre',
                                fontSize: '11px',
                                fontWeight: 'bold'
                            }
                        }, line);
                    }
                } else {
                    // Normal line (light gray background)
                    return React.createElement('div', { 
                        key: idx,
                        style: { 
                            background: '#e0e0e0',  // GRIGIO CHIARO
                            color: 'black',          // TESTO NERO
                            padding: '2px 4px',
                            fontFamily: 'monospace',
                            whiteSpace: 'pre',
                            fontSize: '11px'
                        }
                    }, line);
                }
            };
            
            return React.createElement('div', {
                className: 'hover-popup',
                style: {
                    left: popup.x + 'px',
                    top: popup.y + 'px',
                    maxWidth: popup.type === 'output' ? '500px' : '600px'
                },
                onDoubleClick: () => {
                    setPopupPinned(false);
                    setHoverPopup(null);
                }
            },
                React.createElement('div', { className: 'hover-popup-title' },
                    popup.type === 'input' ? 'üì• Input Context' : 'üì§ Generated XML Code'
                ),
                React.createElement('div', { 
                    className: 'hover-popup-code',
                    style: {
                        background: popup.type === 'input' ? '#f5f5f5' : 'black',
                        padding: '8px',
                        border: '1px solid #ccc'
                    }
                },
                    popup.type === 'input' 
                        ? (popup.lines || popup.contextLines || []).map((line, idx) => renderInputLine(line, idx))
                        : React.createElement('pre', { 
                            style: { 
                                margin: 0,
                                color: '#0f0',
                                fontFamily: 'monospace',
                                fontSize: '12px',
                                whiteSpace: 'pre-wrap'
                            }
                        }, popup.code)
                )
            );
        }
        
        // Formula Editor Component
        function FormulaEditor({ connection, onSave, onClose }) {
            const [expression, setExpression] = useState(
                connection.transformation?.expression || ''
            );
            const textareaRef = useRef(null);

            const snippets = [
                { label: 'Upper',        code: 'value.upper()' },
                { label: 'Lower',        code: 'value.lower()' },
                { label: 'Trim',         code: 'value.strip()' },
                { label: 'Replace',      code: 'value.replace("old", "new")' },
                { label: 'Split [0]',    code: 'value.split("/")[0]' },
                { label: '√ó 100',        code: 'float(value) * 100' },
                { label: '√∑ 100',        code: 'float(value) / 100' },
                { label: 'Round 2',      code: 'round(float(value), 2)' },
                { label: 'Substring',    code: 'value[0:8]' },
                { label: 'Pad 0 √ó10',   code: 'value.zfill(10)' },
                { label: 'Date ISO',     code: 'value[0:10]' },
                { label: 'Default EUR',  code: 'value if value else "EUR"' },
                { label: 'Strip alpha',  code: 'import re; re.sub(r"[^0-9.]", "", value)' },
                { label: 'Negate',       code: 'str(-float(value))' },
            ];

            const insertSnippet = (code) => {
                const ta = textareaRef.current;
                if (!ta) return;
                const s = ta.selectionStart, e = ta.selectionEnd;
                const next = expression.slice(0,s) + code + expression.slice(e);
                setExpression(next);
                setTimeout(() => { ta.focus(); ta.selectionStart = ta.selectionEnd = s + code.length; }, 0);
            };

            const panelStyle = { background: '#1e1e2e', color: '#cdd6f4', borderRadius: '8px', width: '680px', maxHeight: '85vh', display: 'flex', flexDirection: 'column', boxShadow: '0 10px 40px rgba(0,0,0,0.6)' };
            const headerStyle = { padding: '16px 20px', borderBottom: '1px solid #313244', display: 'flex', alignItems: 'center', justifyContent: 'space-between' };
            const bodyStyle = { padding: '16px 20px', flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '12px' };
            const labelStyle = { fontSize: '11px', fontWeight: '700', color: '#a6adc8', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px' };
            const taStyle = { width: '100%', minHeight: '120px', padding: '12px', fontFamily: '"Fira Code", "Courier New", monospace', fontSize: '13px', background: '#181825', color: '#cdd6f4', border: '1px solid #45475a', borderRadius: '6px', resize: 'vertical', outline: 'none' };
            const snippetBtn = { padding: '4px 10px', background: '#313244', color: '#cdd6f4', border: '1px solid #45475a', borderRadius: '4px', cursor: 'pointer', fontSize: '11px', fontFamily: 'monospace', transition: 'all 0.15s' };
            const hintBox = { background: '#181825', border: '1px solid #45475a', borderRadius: '6px', padding: '10px 14px', fontSize: '11px', color: '#a6adc8', lineHeight: '1.7' };

            return React.createElement('div', { className: 'formula-editor-modal', onClick: onClose },
                React.createElement('div', { style: panelStyle, onClick: e => e.stopPropagation() },
                    React.createElement('div', { style: headerStyle },
                        React.createElement('div', null,
                            React.createElement('div', { style: { fontWeight: '700', fontSize: '15px', color: '#cdd6f4' } }, '‚úèÔ∏è Custom Formula'),
                            React.createElement('div', { style: { fontSize: '11px', color: '#6c7086', marginTop: '2px' } },
                                connection.sourceName + '  ‚Üí  ' + connection.targetName)
                        ),
                        React.createElement('button', { onClick: onClose, style: { background: 'none', border: 'none', color: '#6c7086', fontSize: '20px', cursor: 'pointer' } }, '‚úï')
                    ),
                    React.createElement('div', { style: bodyStyle },
                        React.createElement('div', null,
                            React.createElement('div', { style: labelStyle }, 'Expression Python ‚Äî usa "value" come variabile sorgente'),
                            React.createElement('textarea', {
                                ref: textareaRef,
                                style: taStyle,
                                value: expression,
                                onChange: e => setExpression(e.target.value),
                                placeholder: 'es: value.upper()  oppure  float(value) * 100  oppure  value.split("/")[0]',
                                spellCheck: false
                            })
                        ),
                        React.createElement('div', null,
                            React.createElement('div', { style: labelStyle }, 'Snippet rapidi'),
                            React.createElement('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px' } },
                                snippets.map(s => React.createElement('button', {
                                    key: s.label,
                                    style: snippetBtn,
                                    onClick: () => insertSnippet(s.code),
                                    onMouseEnter: e => { e.target.style.background = '#45475a'; e.target.style.color = '#cba6f7'; },
                                    onMouseLeave: e => { e.target.style.background = '#313244'; e.target.style.color = '#cdd6f4'; }
                                }, s.label))
                            )
                        ),
                        React.createElement('div', { style: hintBox },
                            React.createElement('strong', { style: { color: '#cba6f7' } }, 'Suggerimenti: '),
                            React.createElement('span', null, '"value" contiene sempre il valore del campo sorgente come stringa. '),
                            React.createElement('span', null, 'Puoi usare qualsiasi espressione Python su una riga. '),
                            React.createElement('br', null),
                            React.createElement('strong', { style: { color: '#89dceb' } }, 'Esempi: '),
                            React.createElement('code', { style: { color: '#a6e3a1' } }, 'value.strip().upper()'),
                            React.createElement('span', null, ' ¬∑ '),
                            React.createElement('code', { style: { color: '#a6e3a1' } }, 'value[0:4] + "-" + value[4:6]'),
                            React.createElement('span', null, ' ¬∑ '),
                            React.createElement('code', { style: { color: '#a6e3a1' } }, '"IT" + value if not value.startswith("IT") else value')
                        )
                    ),
                    React.createElement('div', { style: { padding: '12px 20px', borderTop: '1px solid #313244', display: 'flex', gap: '10px', justifyContent: 'flex-end' } },
                        React.createElement('button', { className: 'btn btn-secondary', onClick: onClose }, 'Annulla'),
                        React.createElement('button', { className: 'btn btn-success', onClick: () => onSave({ type: 'CUSTOM', expression }) }, '‚úÖ Salva Formula')
                    )
                )
            );
        }
        
        // Settings Modal Component
        function SettingsModal({ onClose }) {
            return React.createElement('div', {
                className: 'formula-editor-modal',
                onClick: onClose
            },
                React.createElement('div', {
                    className: 'formula-editor',
                    onClick: (e) => e.stopPropagation()
                },
                    React.createElement('div', { className: 'formula-editor-header' },
                        React.createElement('h3', null, '‚öôÔ∏è AI Configuration')
                    ),
                    React.createElement('div', { className: 'formula-editor-body' },
                        React.createElement('div', { style: { padding: '15px', background: '#f0f0f0', borderRadius: '6px', fontSize: '13px', marginBottom: '15px' } },
                            React.createElement('strong', null, 'ü§ñ How AI Auto-Map Works:'),
                            React.createElement('ul', { style: { marginTop: '8px', paddingLeft: '20px', lineHeight: '1.6' } },
                                React.createElement('li', null, 'AI analyzes your input and output schemas'),
                                React.createElement('li', null, 'Considers field names, types, business terms, and data samples'),
                                React.createElement('li', null, 'Suggests intelligent mappings with confidence scores'),
                                React.createElement('li', null, 'Recommends transformation formulas when needed')
                            )
                        ),
                        React.createElement('div', { style: { padding: '15px', background: '#fff3cd', borderRadius: '6px', fontSize: '12px', marginBottom: '15px' } },
                            React.createElement('strong', { style: { display: 'block', marginBottom: '8px' } }, 'üîë API Keys Configuration:'),
                            React.createElement('div', { style: { lineHeight: '1.6' } },
                                'API keys are configured in the backend ',
                                React.createElement('code', { style: { background: '#fff', padding: '2px 6px', borderRadius: '3px' } }, '.env'),
                                ' file. Add your keys there:',
                                React.createElement('pre', { style: { background: '#000', color: '#0f0', padding: '10px', borderRadius: '4px', marginTop: '8px', fontSize: '11px', overflow: 'auto' } },
`ANTHROPIC_API_KEY=sk-ant-api03-...
OPENAI_API_KEY=sk-...`
                                )
                            )
                        ),
                        React.createElement('div', { style: { fontSize: '12px' } },
                            React.createElement('div', { style: { marginBottom: '10px' } },
                                React.createElement('strong', null, 'ü§ñ Get Claude API Key:'),
                                React.createElement('br'),
                                React.createElement('a', { 
                                    href: 'https://console.anthropic.com/settings/keys', 
                                    target: '_blank',
                                    style: { color: '#00BCD4' }
                                }, 'https://console.anthropic.com/settings/keys')
                            ),
                            React.createElement('div', null,
                                React.createElement('strong', null, 'üß† Get OpenAI API Key:'),
                                React.createElement('br'),
                                React.createElement('a', { 
                                    href: 'https://platform.openai.com/api-keys', 
                                    target: '_blank',
                                    style: { color: '#00BCD4' }
                                }, 'https://platform.openai.com/api-keys')
                            )
                        )
                    ),
                    React.createElement('div', { className: 'formula-editor-footer' },
                        React.createElement('button', {
                            className: 'btn btn-primary',
                            onClick: onClose
                        }, '‚úÖ Got It')
                    )
                )
            );
        }
        
        // ===========================================================================
        // SCHEMA EDITOR MODAL COMPONENT
        // ===========================================================================
        
        function SchemaEditorModal({ show, onClose, onSchemaSelect }) {
            const [schemaId, setSchemaId] = useState(null);
            const [schemaName, setSchemaName] = useState('');
            const [schemaFormat, setSchemaFormat] = useState('xml');
            const [schemaTree, setSchemaTree] = useState([]);
            const [selectedField, setSelectedField] = useState(null);
            const [status, setStatus] = useState('');
            const [savedSchemas, setSavedSchemas] = useState([]);
            const [showLoadPanel, setShowLoadPanel] = useState(false);
            
            // Load list of saved schemas on mount
            useEffect(() => {
                loadSavedSchemasList();
            }, []);
            
            // Load list of saved schemas
            const loadSavedSchemasList = async () => {
                try {
                    const res = await fetch(`${API_URL}/schema/list`);
                    const data = await res.json();
                    setSavedSchemas(data.schemas || []);
                } catch (err) {
                    console.error('Failed to load schemas list:', err);
                }
            };
            
            // Save current schema
            const saveCurrentSchema = async () => {
                if (!schemaId) {
                    setStatus('‚ùå No schema to save');
                    return;
                }
                
                const name = prompt('Schema name:', schemaName);
                if (!name) return;
                
                const description = prompt('Description (optional):');
                
                try {
                    await fetch(`${API_URL}/schema/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            schema_id: schemaId,
                            name,
                            description: description || ''
                        })
                    });
                    setStatus(`‚úÖ Schema "${name}" saved!`);
                    loadSavedSchemasList();
                } catch (err) {
                    setStatus(`‚ùå Save error: ${err.message}`);
                }
            };
            
            // Load saved schema
            const loadSavedSchema = async (storedId) => {
                try {
                    const res = await fetch(`${API_URL}/schema/load/${storedId}`);
                    const data = await res.json();
                    setSchemaId(data.schema_id);
                    setSchemaName(data.schema.name);
                    setSchemaTree(data.tree);
                    setStatus(`‚úÖ Schema loaded!`);
                    setShowLoadPanel(false);
                } catch (err) {
                    setStatus(`‚ùå Load error: ${err.message}`);
                }
            };
            
            // Delete saved schema
            const deleteSavedSchema = async (storedId) => {
                if (!confirm('Delete this saved schema?')) return;
                
                try {
                    await fetch(`${API_URL}/schema/stored/${storedId}`, {
                        method: 'DELETE'
                    });
                    setStatus('‚úÖ Schema deleted');
                    loadSavedSchemasList();
                } catch (err) {
                    setStatus(`‚ùå Delete error: ${err.message}`);
                }
            };
            
            // Create new schema
            const createSchema = async () => {
                try {
                    const res = await fetch(`${API_URL}/schema/create`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: schemaName,
                            format: schemaFormat
                        })
                    });
                    const data = await res.json();
                    setSchemaId(data.schema_id);
                    setStatus(`‚úÖ Schema "${schemaName}" created!`);
                    loadSchema(data.schema_id);
                } catch (err) {
                    setStatus(`‚ùå Error: ${err.message}`);
                }
            };
            
            // Load schema tree
            const loadSchema = async (id) => {
                try {
                    const res = await fetch(`${API_URL}/schema/${id}`);
                    const data = await res.json();
                    setSchemaTree(data.tree);
                } catch (err) {
                    setStatus(`‚ùå Load error: ${err.message}`);
                }
            };
            
            // Add field
            const addField = async () => {
                const name = prompt('Field name:');
                if (!name) return;
                
                const type = prompt('Type (string/number/date/boolean/object/array):', 'string');
                if (!type) return;
                
                const description = prompt('Description (optional):');
                
                try {
                    await fetch(`${API_URL}/schema/${schemaId}/field/add`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name,
                            field_type: type,
                            parent_path: selectedField?.path,
                            description: description || '',
                            required: false
                        })
                    });
                    setStatus(`‚úÖ Field "${name}" added`);
                    loadSchema(schemaId);
                } catch (err) {
                    setStatus(`‚ùå Add field error: ${err.message}`);
                }
            };
            
            // Remove field
            const removeField = async (fieldId) => {
                if (!confirm('Remove this field and all its children?')) return;
                
                try {
                    await fetch(`${API_URL}/schema/${schemaId}/field/${fieldId}`, {
                        method: 'DELETE'
                    });
                    setStatus(`‚úÖ Field removed`);
                    setSelectedField(null);
                    loadSchema(schemaId);
                } catch (err) {
                    setStatus(`‚ùå Remove error: ${err.message}`);
                }
            };
            
            // Update field
            const updateField = async (fieldId, updates) => {
                try {
                    await fetch(`${API_URL}/schema/${schemaId}/field/update`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            field_id: fieldId,
                            updates
                        })
                    });
                    setStatus(`‚úÖ Field updated`);
                    loadSchema(schemaId);
                } catch (err) {
                    setStatus(`‚ùå Update error: ${err.message}`);
                }
            };
            
            // Export as CSV
            const exportCSV = () => {
                window.open(`${API_URL}/schema/${schemaId}/export/csv`);
                setStatus('‚úÖ Exporting CSV schema...');
            };
            
            // Export sample
            const exportSample = (format) => {
                window.open(`${API_URL}/schema/${schemaId}/export/sample/${format}`);
                setStatus(`‚úÖ Exporting sample ${format.toUpperCase()}...`);
            };
            
            // Import from CSV header
            const importCSV = async () => {
                const header = prompt('Enter CSV header (comma-separated):');
                if (!header) return;
                
                try {
                    await fetch(`${API_URL}/schema/${schemaId}/import`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            format: 'csv_header',
                            content: header
                        })
                    });
                    setStatus('‚úÖ Imported from CSV header');
                    loadSchema(schemaId);
                } catch (err) {
                    setStatus(`‚ùå Import error: ${err.message}`);
                }
            };
            
            // Render tree node
            const renderTreeNode = (node, level = 0) => {
                const indent = level * 20;
                const isSelected = selectedField?.id === node.id;
                
                const getTypeIcon = (type) => {
                    const icons = {
                        string: 'üìù',
                        number: 'üî¢',
                        date: 'üìÖ',
                        boolean: '‚òëÔ∏è',
                        array: 'üìã',
                        object: 'üì¶'
                    };
                    return icons[type] || 'üìÑ';
                };
                
                return React.createElement('div', { key: node.id },
                    React.createElement('div', {
                        style: {
                            paddingLeft: `${indent + 8}px`,
                            padding: '8px',
                            cursor: 'pointer',
                            background: isSelected ? '#e3f2fd' : 'transparent',
                            borderLeft: isSelected ? '3px solid #1976d2' : 'none',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            borderRadius: '4px'
                        },
                        onClick: () => setSelectedField(node)
                    },
                        React.createElement('span', null, getTypeIcon(node.type)),
                        React.createElement('span', { 
                            style: { fontWeight: 'bold', flex: 1 } 
                        }, node.name),
                        React.createElement('span', { 
                            style: { fontSize: '11px', color: '#666' }
                        }, node.type),
                        node.required && React.createElement('span', {
                            style: { color: 'red', fontSize: '11px', marginLeft: '4px' }
                        }, '*'),
                        React.createElement('button', {
                            onClick: (e) => {
                                e.stopPropagation();
                                removeField(node.id);
                            },
                            style: { 
                                marginLeft: '8px', 
                                fontSize: '16px',
                                background: 'none',
                                border: 'none',
                                cursor: 'pointer'
                            }
                        }, 'üóëÔ∏è')
                    ),
                    node.children?.map(child => renderTreeNode(child, level + 1))
                );
            };
            
            if (!show) return null;
            
            return React.createElement('div', {
                className: 'modal-overlay',
                onClick: onClose
            },
                React.createElement('div', {
                    className: 'modal',
                    style: { maxWidth: '1200px', width: '90%', maxHeight: '90vh' },
                    onClick: (e) => e.stopPropagation()
                },
                    React.createElement('h2', null, 'üèóÔ∏è Schema Editor'),
                    
                    // Status bar
                    status && React.createElement('div', {
                        style: {
                            padding: '10px',
                            marginTop: '10px',
                            marginBottom: '10px',
                            background: status.startsWith('‚úÖ') ? '#d4edda' : '#f8d7da',
                            color: status.startsWith('‚úÖ') ? '#155724' : '#721c24',
                            borderRadius: '6px'
                        }
                    }, status),
                    
                    // Header section - Create or Load schema
                    !schemaId && React.createElement('div', { style: { marginBottom: '20px' } },
                        React.createElement('div', { 
                            style: { 
                                display: 'flex', 
                                gap: '10px', 
                                alignItems: 'center',
                                marginBottom: '15px'
                            }
                        },
                            React.createElement('input', {
                                type: 'text',
                                placeholder: 'Schema name (e.g., Invoice, Customer)...',
                                value: schemaName,
                                onChange: (e) => setSchemaName(e.target.value),
                                style: { width: '300px' }
                            }),
                            React.createElement('select', {
                                value: schemaFormat,
                                onChange: (e) => setSchemaFormat(e.target.value)
                            },
                                React.createElement('option', { value: 'csv' }, 'CSV'),
                                React.createElement('option', { value: 'xml' }, 'XML'),
                                React.createElement('option', { value: 'json' }, 'JSON'),
                                React.createElement('option', { value: 'excel' }, 'Excel'),
                                React.createElement('option', { value: 'flat' }, 'Fixed-width (IDOC)')
                            ),
                            React.createElement('button', {
                                className: 'btn btn-primary',
                                onClick: createSchema,
                                disabled: !schemaName
                            }, '‚ú® Create New'),
                            React.createElement('button', {
                                className: 'btn btn-secondary',
                                onClick: () => setShowLoadPanel(!showLoadPanel)
                            }, showLoadPanel ? '‚úñ Close' : 'üìÇ Load Saved')
                        ),
                        
                        // Load panel
                        showLoadPanel && React.createElement('div', {
                            style: {
                                border: '2px solid #00BCD4',
                                borderRadius: '8px',
                                padding: '15px',
                                background: '#f8f9ff',
                                maxHeight: '300px',
                                overflowY: 'auto'
                            }
                        },
                            React.createElement('h4', { 
                                style: { marginTop: 0, marginBottom: '10px' }
                            }, 'üìö Saved Schemas'),
                            savedSchemas.length === 0 ? React.createElement('p', {
                                style: { color: '#999', textAlign: 'center', padding: '20px' }
                            }, 'No saved schemas yet. Create and save one first!') : null,
                            savedSchemas.map(schema => 
                                React.createElement('div', {
                                    key: schema.id,
                                    style: {
                                        padding: '10px',
                                        marginBottom: '8px',
                                        background: 'white',
                                        borderRadius: '6px',
                                        border: '1px solid #ddd',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '10px'
                                    }
                                },
                                    React.createElement('div', { style: { flex: 1 } },
                                        React.createElement('div', { 
                                            style: { fontWeight: 'bold', marginBottom: '4px' }
                                        }, schema.name),
                                        React.createElement('div', { 
                                            style: { fontSize: '12px', color: '#666' }
                                        }, `${schema.format.toUpperCase()} ‚Ä¢ ${schema.field_count} fields`),
                                        schema.description && React.createElement('div', {
                                            style: { fontSize: '11px', color: '#999', marginTop: '4px' }
                                        }, schema.description)
                                    ),
                                    React.createElement('button', {
                                        className: 'btn btn-sm btn-primary',
                                        onClick: () => loadSavedSchema(schema.id)
                                    }, 'üì• Load'),
                                    React.createElement('button', {
                                        className: 'btn btn-sm btn-danger',
                                        onClick: () => deleteSavedSchema(schema.id)
                                    }, 'üóëÔ∏è')
                                )
                            )
                        )
                    ),
                    
                    // Main editor area
                    schemaId && React.createElement('div', {
                        style: { display: 'flex', gap: '20px', height: '500px' }
                    },
                        // Left - Tree view
                        React.createElement('div', {
                            style: {
                                flex: 1,
                                border: '1px solid #ddd',
                                borderRadius: '6px',
                                padding: '10px',
                                overflowY: 'auto',
                                background: '#fafafa'
                            }
                        },
                            React.createElement('div', {
                                style: { 
                                    marginBottom: '10px',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    paddingBottom: '10px',
                                    borderBottom: '2px solid #ddd'
                                }
                            },
                                React.createElement('h3', { 
                                    style: { margin: 0 }
                                }, `üìÇ ${schemaName}`),
                                React.createElement('div', { 
                                    style: { display: 'flex', gap: '5px' } 
                                },
                                    React.createElement('button', {
                                        className: 'btn btn-sm btn-primary',
                                        onClick: addField
                                    }, '‚ûï Add'),
                                    React.createElement('button', {
                                        className: 'btn btn-sm btn-secondary',
                                        onClick: importCSV
                                    }, 'üì• Import')
                                )
                            ),
                            schemaTree.length === 0 ? React.createElement('div', {
                                style: { 
                                    textAlign: 'center', 
                                    padding: '40px', 
                                    color: '#999' 
                                }
                            }, 'No fields yet. Click "Add" to start.') : null,
                            schemaTree.map(node => renderTreeNode(node))
                        ),
                        
                        // Right - Properties panel
                        React.createElement('div', {
                            style: {
                                width: '350px',
                                border: '1px solid #ddd',
                                borderRadius: '6px',
                                padding: '15px',
                                overflowY: 'auto'
                            }
                        },
                            React.createElement('h3', null, '‚öôÔ∏è Properties'),
                            selectedField ? React.createElement('div', null,
                                React.createElement('div', { 
                                    style: { marginBottom: '15px' } 
                                },
                                    React.createElement('label', { 
                                        style: { 
                                            display: 'block', 
                                            fontWeight: 'bold', 
                                            marginBottom: '5px',
                                            fontSize: '11px',
                                            color: '#666',
                                            textTransform: 'uppercase'
                                        } 
                                    }, 'Name:'),
                                    React.createElement('div', { 
                                        style: { 
                                            fontWeight: 'bold', 
                                            fontSize: '18px' 
                                        } 
                                    }, selectedField.name)
                                ),
                                React.createElement('div', { 
                                    style: { marginBottom: '15px' } 
                                },
                                    React.createElement('label', {
                                        style: { 
                                            display: 'block', 
                                            fontWeight: 'bold', 
                                            marginBottom: '5px',
                                            fontSize: '11px',
                                            color: '#666',
                                            textTransform: 'uppercase'
                                        }
                                    }, 'Type:'),
                                    React.createElement('div', { 
                                        style: { 
                                            padding: '8px',
                                            background: '#f5f5f5',
                                            borderRadius: '4px',
                                            fontFamily: 'monospace'
                                        }
                                    }, selectedField.type)
                                ),
                                React.createElement('div', { 
                                    style: { marginBottom: '15px' } 
                                },
                                    React.createElement('label', {
                                        style: { 
                                            display: 'block', 
                                            fontWeight: 'bold', 
                                            marginBottom: '5px',
                                            fontSize: '11px',
                                            color: '#666',
                                            textTransform: 'uppercase'
                                        }
                                    }, 'Path:'),
                                    React.createElement('div', { 
                                        style: { 
                                            fontSize: '12px', 
                                            color: '#666',
                                            fontFamily: 'monospace',
                                            wordBreak: 'break-all'
                                        }
                                    }, selectedField.path)
                                ),
                                React.createElement('div', { 
                                    style: { marginBottom: '15px' } 
                                },
                                    React.createElement('label', {
                                        style: { 
                                            display: 'block', 
                                            fontWeight: 'bold', 
                                            marginBottom: '5px',
                                            fontSize: '11px',
                                            color: '#666',
                                            textTransform: 'uppercase'
                                        }
                                    }, 'Description:'),
                                    React.createElement('textarea', {
                                        value: selectedField.description || '',
                                        onChange: (e) => updateField(selectedField.id, { 
                                            description: e.target.value 
                                        }),
                                        style: { 
                                            width: '100%', 
                                            height: '80px',
                                            padding: '8px',
                                            border: '1px solid #ddd',
                                            borderRadius: '4px'
                                        },
                                        placeholder: 'Enter field description...'
                                    })
                                ),
                                React.createElement('div', { 
                                    style: { marginBottom: '15px' } 
                                },
                                    React.createElement('label', {
                                        style: { 
                                            display: 'flex',
                                            alignItems: 'center',
                                            cursor: 'pointer'
                                        }
                                    },
                                        React.createElement('input', {
                                            type: 'checkbox',
                                            checked: selectedField.required || false,
                                            onChange: (e) => updateField(selectedField.id, {
                                                required: e.target.checked
                                            }),
                                            style: { marginRight: '8px' }
                                        }),
                                        React.createElement('span', {
                                            style: { fontWeight: 'bold' }
                                        }, 'Required field')
                                    )
                                )
                            ) : React.createElement('p', { 
                                style: { 
                                    color: '#999', 
                                    textAlign: 'center',
                                    padding: '40px 20px'
                                } 
                            }, 'Select a field from the tree to edit its properties')
                        )
                    ),
                    
                    // Footer - Export buttons
                    schemaId && React.createElement('div', {
                        style: {
                            marginTop: '20px',
                            paddingTop: '20px',
                            borderTop: '2px solid #ddd',
                            display: 'flex',
                            gap: '10px',
                            flexWrap: 'wrap'
                        }
                    },
                        React.createElement('button', {
                            className: 'btn btn-success',
                            onClick: saveCurrentSchema,
                            title: 'Save this schema for reuse in other projects'
                        }, 'üíæ Save Schema'),
                        React.createElement('button', {
                            className: 'btn btn-success',
                            onClick: exportCSV
                        }, 'üì• Export CSV Schema'),
                        React.createElement('button', {
                            className: 'btn btn-secondary',
                            onClick: () => exportSample('xml')
                        }, 'üìÑ Sample XML'),
                        React.createElement('button', {
                            className: 'btn btn-secondary',
                            onClick: () => exportSample('json')
                        }, 'üìÑ Sample JSON'),
                        React.createElement('button', {
                            className: 'btn btn-secondary',
                            onClick: () => exportSample('csv')
                        }, 'üìÑ Sample CSV'),
                        React.createElement('div', { 
                            style: { flex: 1, borderRight: '2px solid #ddd', marginLeft: '10px' } 
                        }),
                        onSchemaSelect && React.createElement('button', {
                            className: 'btn btn-success',
                            onClick: async () => {
                                // Export CSV and set as input schema
                                try {
                                    const res = await fetch(`${API_URL}/schema/${schemaId}/export/csv`);
                                    const csvText = await res.text();
                                    
                                    // Parse CSV as schema
                                    const formData = new FormData();
                                    const blob = new Blob([csvText], { type: 'text/csv' });
                                    formData.append('file', blob, 'schema.csv');
                                    formData.append('type', 'csv');
                                    
                                    const uploadRes = await fetch(`${API_URL}/schemas/upload`, {
                                        method: 'POST',
                                        body: formData
                                    });
                                    const schema = await uploadRes.json();
                                    onSchemaSelect(schema, 'input', { schema: schemaTree, schemaId });
                                    onClose();
                                } catch (err) {
                                    setStatus(`‚ùå Error: ${err.message}`);
                                }
                            }
                        }, 'üì• Use as Input Schema'),
                        onSchemaSelect && React.createElement('button', {
                            className: 'btn btn-success',
                            onClick: async () => {
                                // Export CSV and set as output schema
                                try {
                                    const res = await fetch(`${API_URL}/schema/${schemaId}/export/csv`);
                                    const csvText = await res.text();
                                    
                                    // Parse CSV as schema
                                    const formData = new FormData();
                                    const blob = new Blob([csvText], { type: 'text/csv' });
                                    formData.append('file', blob, 'schema.csv');
                                    formData.append('type', 'csv');
                                    
                                    const uploadRes = await fetch(`${API_URL}/schemas/upload`, {
                                        method: 'POST',
                                        body: formData
                                    });
                                    const schema = await uploadRes.json();
                                    onSchemaSelect(schema, 'output', { schema: schemaTree, schemaId });
                                    onClose();
                                } catch (err) {
                                    setStatus(`‚ùå Error: ${err.message}`);
                                }
                            }
                        }, 'üì§ Use as Output Schema'),
                        React.createElement('button', {
                            className: 'btn btn-primary',
                            onClick: () => {
                                onClose();
                            },
                            style: { marginLeft: 'auto' }
                        }, '‚úÖ Done')
                    ),
                    
                    React.createElement('button', {
                        className: 'btn btn-secondary',
                        onClick: onClose,
                        style: { marginTop: '10px', width: '100%' }
                    }, '‚ùå Close')
                )
            );
        }
        
        // AI Suggestions Panel Component
        function AISuggestionsPanel({ suggestions, onApprove, onReject, onClose, processing }) {
            const [selectedIds, setSelectedIds] = useState(new Set());
            const [selectAll, setSelectAll] = useState(false);
            
            const toggleSelection = (suggestion) => {
                const key = `${suggestion.source_field}-${suggestion.target_field}`;
                const newSelectedIds = new Set(selectedIds);
                
                if (newSelectedIds.has(key)) {
                    newSelectedIds.delete(key);
                } else {
                    newSelectedIds.add(key);
                }
                
                setSelectedIds(newSelectedIds);
                setSelectAll(newSelectedIds.size === suggestions.length);
            };
            
            const toggleSelectAll = () => {
                if (selectAll) {
                    setSelectedIds(new Set());
                    setSelectAll(false);
                } else {
                    const allIds = new Set(
                        suggestions.map(s => `${s.source_field}-${s.target_field}`)
                    );
                    setSelectedIds(allIds);
                    setSelectAll(true);
                }
            };
            
            const isSelected = (suggestion) => {
                const key = `${suggestion.source_field}-${suggestion.target_field}`;
                return selectedIds.has(key);
            };
            
            const approveSelected = () => {
                console.log('üü¢ APPROVE SELECTED clicked');
                console.log('  Selected IDs:', selectedIds);
                
                const toApprove = suggestions.filter(s => isSelected(s));
                console.log('  To approve count:', toApprove.length);
                console.log('  To approve items:', toApprove.map(s => s.source_field + ' ‚Üí ' + s.target_field));
                
                // Approve with small delay between each to ensure unique IDs
                toApprove.forEach((s, index) => {
                    setTimeout(() => {
                        console.log(`  [${index}] Approving:`, s.source_field, '‚Üí', s.target_field);
                        onApprove(s);
                    }, index * 50);
                });
                
                setSelectedIds(new Set());
                setSelectAll(false);
            };
            
            const approveAll = () => {
                console.log('üü£ APPROVE ALL clicked');
                console.log('  Total suggestions:', suggestions.length);
                console.log('  Suggestions:', suggestions.map(s => s.source_field + ' ‚Üí ' + s.target_field));
                
                // Approve with small delay between each to ensure unique IDs
                suggestions.forEach((s, index) => {
                    setTimeout(() => {
                        console.log(`  [${index}] Approving:`, s.source_field, '‚Üí', s.target_field);
                        onApprove(s);
                    }, index * 50);
                });
                
                setSelectedIds(new Set());
                setSelectAll(false);
            };
            
            return React.createElement('div', {
                style: {
                    position: 'fixed',
                    right: '20px',
                    top: '80px',
                    width: '450px',
                    maxHeight: 'calc(100vh - 100px)',
                    background: 'white',
                    borderRadius: '12px',
                    boxShadow: '0 10px 40px rgba(0,0,0,0.2)',
                    border: '2px solid #00BCD4',
                    zIndex: 1000,
                    display: 'flex',
                    flexDirection: 'column'
                }
            },
                React.createElement('div', {
                    style: {
                        padding: '20px',
                        borderBottom: '1px solid #ddd',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        background: 'linear-gradient(135deg, #00BCD4 0%, #3F51B5 100%)',
                        color: 'white',
                        borderRadius: '10px 10px 0 0'
                    }
                },
                    React.createElement('h3', { style: { margin: 0, fontSize: '16px' } }, 
                        processing ? '‚è≥ AI Analyzing...' : `ü§ñ Suggestions (${suggestions.length})`
                    ),
                    React.createElement('button', {
                        onClick: onClose,
                        style: {
                            background: 'none',
                            border: 'none',
                            color: 'white',
                            fontSize: '20px',
                            cursor: 'pointer',
                            padding: '0 5px'
                        }
                    }, '√ó')
                ),
                !processing && suggestions.length > 0 && React.createElement('div', {
                    style: {
                        padding: '10px 15px',
                        background: '#f5f5f5',
                        borderBottom: '1px solid #ddd',
                        display: 'flex',
                        gap: '10px',
                        alignItems: 'center'
                    }
                },
                    React.createElement('input', {
                        type: 'checkbox',
                        checked: selectAll,
                        onChange: toggleSelectAll,
                        style: { cursor: 'pointer' }
                    }),
                    React.createElement('span', { 
                        style: { fontSize: '12px', fontWeight: 'bold', flex: 1 }
                    }, `Select All (${selectedIds.size}/${suggestions.length})`),
                    React.createElement('button', {
                        className: 'btn btn-success',
                        onClick: approveSelected,
                        disabled: selectedIds.size === 0,
                        style: { fontSize: '11px', padding: '5px 10px' }
                    }, `‚úÖ Approve Selected (${selectedIds.size})`),
                    React.createElement('button', {
                        className: 'btn btn-primary',
                        onClick: approveAll,
                        style: { fontSize: '11px', padding: '5px 10px' }
                    }, '‚úÖ Approve All')
                ),
                React.createElement('div', {
                    style: {
                        flex: 1,
                        overflowY: 'auto',
                        padding: '15px'
                    }
                },
                    processing ? React.createElement('div', {
                        style: { textAlign: 'center', padding: '40px', color: '#666' }
                    },
                        React.createElement('div', { style: { fontSize: '48px', marginBottom: '10px' } }, 'ü§ñ'),
                        React.createElement('div', null, 'AI is analyzing your schemas...'),
                        React.createElement('div', { style: { fontSize: '12px', marginTop: '5px' } }, 'This may take 10-30 seconds')
                    ) : suggestions.length === 0 ? React.createElement('div', {
                        style: { textAlign: 'center', padding: '40px', color: '#666' }
                    },
                        React.createElement('div', { style: { fontSize: '48px', marginBottom: '10px' } }, 'üéâ'),
                        React.createElement('div', null, 'No suggestions remaining'),
                        React.createElement('div', { style: { fontSize: '12px', marginTop: '5px' } }, 'All mappings reviewed!')
                    ) : suggestions.map((suggestion, idx) =>
                        React.createElement('div', {
                            key: idx,
                            style: {
                                padding: '15px',
                                background: isSelected(suggestion) ? '#e8f4ff' : '#f9f9f9',
                                borderRadius: '8px',
                                marginBottom: '10px',
                                border: isSelected(suggestion) ? '2px solid #00BCD4' : '1px solid #ddd'
                            }
                        },
                            React.createElement('div', {
                                style: { display: 'flex', gap: '10px', alignItems: 'flex-start' }
                            },
                                React.createElement('input', {
                                    type: 'checkbox',
                                    checked: isSelected(suggestion),
                                    onChange: () => toggleSelection(suggestion),
                                    style: { 
                                        cursor: 'pointer',
                                        marginTop: '3px',
                                        width: '16px',
                                        height: '16px'
                                    }
                                }),
                                React.createElement('div', { style: { flex: 1 } },
                                    React.createElement('div', {
                                        style: {
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            marginBottom: '10px'
                                        }
                                    },
                                        React.createElement('span', {
                                            style: {
                                                fontSize: '11px',
                                                padding: '4px 8px',
                                                borderRadius: '12px',
                                                fontWeight: 'bold',
                                                background: suggestion.confidence > 0.8 ? '#d4edda' : 
                                                           suggestion.confidence > 0.6 ? '#fff3cd' : '#f8d7da',
                                                color: suggestion.confidence > 0.8 ? '#155724' :
                                                       suggestion.confidence > 0.6 ? '#856404' : '#721c24'
                                            }
                                        }, `${Math.round(suggestion.confidence * 100)}% confident`)
                                    ),
                                    React.createElement('div', {
                                        style: {
                                            fontSize: '12px',
                                            fontFamily: 'monospace',
                                            marginBottom: '8px',
                                            fontWeight: 'bold'
                                        }
                                    }, 
                                        `üì• ${suggestion.source_field}`,
                                        React.createElement('div', { style: { color: '#00BCD4', margin: '5px 0' } }, '‚Üì'),
                                        `üì§ ${suggestion.target_field}`
                                    ),
                                    suggestion.suggested_formula && React.createElement('div', {
                                        style: {
                                            fontSize: '11px',
                                            padding: '8px',
                                            background: '#fff',
                                            borderRadius: '4px',
                                            fontFamily: 'monospace',
                                            marginBottom: '8px',
                                            border: '1px solid #ddd'
                                        }
                                    }, `‚úèÔ∏è ${suggestion.suggested_formula}`),
                                    React.createElement('div', {
                                        style: {
                                            fontSize: '11px',
                                            color: '#666',
                                            fontStyle: 'italic',
                                            marginBottom: '10px',
                                            lineHeight: '1.4'
                                        }
                                    }, `üí° ${suggestion.reasoning}`),
                                    React.createElement('div', {
                                        style: { display: 'flex', gap: '8px' }
                                    },
                                        React.createElement('button', {
                                            className: 'btn btn-success',
                                            style: { flex: 1, fontSize: '11px', padding: '8px' },
                                            onClick: () => onApprove(suggestion)
                                        }, '‚úÖ Apply'),
                                        React.createElement('button', {
                                            className: 'btn btn-danger',
                                            style: { flex: 1, fontSize: '11px', padding: '8px' },
                                            onClick: () => onReject(suggestion)
                                        }, '‚úï Reject')
                                    )
                                )
                            )
                        )
                    )
                )
            );
        }
        
        function App() {
            const [inputSchema, setInputSchema] = useState(null);
            const [outputSchema, setOutputSchema] = useState(null);
            const [inputSchemaDefinition, setInputSchemaDefinition] = useState(null); // Schema Editor definition
            const [outputSchemaDefinition, setOutputSchemaDefinition] = useState(null); // Schema Editor definition
            const [connections, setConnections] = useState([]);
            const [selectedConnection, setSelectedConnection] = useState(null);
            const [draggedField, setDraggedField] = useState(null);
            const [mappingName, setMappingName] = useState('');
            const [statusMessage, setStatusMessage] = useState(null);
            const [showUploadModal, setShowUploadModal] = useState(false);
            const [uploadDirection, setUploadDirection] = useState('input');
            const [activeTab, setActiveTab] = useState('input');
            const [fieldPositions, setFieldPositions] = useState({});
            const [sessionLoaded, setSessionLoaded] = useState(false);
            const [inputExample, setInputExample] = useState('');
            const [outputExample, setOutputExample] = useState('');
            const [hoverPopup, setHoverPopup] = useState(null);
            const [showFormulaEditor, setShowFormulaEditor] = useState(false);
            const [availableFormulas, setAvailableFormulas] = useState([]);
            const [editingConnection, setEditingConnection] = useState(null);
            
            // AI Integration
            const [aiSuggestions, setAiSuggestions] = useState([]);
            const [showAiPanel, setShowAiPanel] = useState(false);
            const [aiProcessing, setAiProcessing] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [selectedOutputField, setSelectedOutputField] = useState(null);
            
            // Schema Editor
            const [showSchemaEditor, setShowSchemaEditor] = useState(false);
            
            // Sidebar visibility
            const [showSidebar, setShowSidebar] = useState(true);
            
            // Search functionality
            const [searchQuery, setSearchQuery] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [currentSearchIndex, setCurrentSearchIndex] = useState(-1);
            const [highlightedField, setHighlightedField] = useState(null);
            
            // Persistent popup
            const [popupPinned, setPopupPinned] = useState(false);
            
            // Hide/show connected fields
            const [hideConnected, setHideConnected] = useState(false);
            
            // Available schemas from backend
            const [availableInputSchemas, setAvailableInputSchemas] = useState([]);
            const [availableOutputSchemas, setAvailableOutputSchemas] = useState([]);
            
            // Selected schema IDs (for persistence and reverse mapping)
            const [inputSchemaId, setInputSchemaId] = useState('');
            const [outputSchemaId, setOutputSchemaId] = useState('');
            
            // Node import / bundle / edit features
            const [showNodeImportModal, setShowNodeImportModal] = useState(false);
            const [nodeImportDirection, setNodeImportDirection] = useState('input');
            const [nodeBundles, setNodeBundles] = useState([]);
            const [contextMenu, setContextMenu] = useState(null); // { x, y, field, colType }
            const [editingNode, setEditingNode] = useState(null);  // { field, colType }

            const canvasRef = useRef(null);
            const hoverTimeoutRef = useRef(null);
            
            const showStatus = (message, type) => {
                setStatusMessage({ message, type });
                setTimeout(() => setStatusMessage(null), 5000);
            };
            
            // Load session on mount
            useEffect(() => {
                loadSession();
                loadAvailableSchemas();
            }, []);
            
            // Load available schemas from /api/schemas/list
            const loadAvailableSchemas = async () => {
                try {
                    const res = await fetch(`${API_URL}/schemas/list`);
                    if (!res.ok) {
                        console.error('Failed to load schemas');
                        return;
                    }
                    const data = await res.json();
                    
                    // Update state instead of manipulating DOM
                    setAvailableInputSchemas(data.input || []);
                    setAvailableOutputSchemas(data.output || []);
                    
                    console.log('‚úÖ Loaded schemas:', data);
                } catch (err) {
                    console.error('Failed to load available schemas:', err);
                }
            };
            
            // Auto-save to localStorage every 30 seconds
            useEffect(() => {
                if (!sessionLoaded) return;
                
                const autoSave = setInterval(() => {
                    saveToLocalStorage();
                }, 30000); // 30 seconds
                
                return () => clearInterval(autoSave);
            }, [inputSchema, outputSchema, connections, mappingName, sessionLoaded]);
            
            // Save on window close
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    saveToLocalStorage();
                };
                
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [inputSchema, outputSchema, connections, mappingName]);
            
            const saveToLocalStorage = () => {
                try {
                    const session = {
                        inputSchema,
                        outputSchema,
                        inputSchemaId,
                        outputSchemaId,
                        connections,
                        mappingName,
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem('mappingSession', JSON.stringify(session));
                } catch (error) {
                    console.error('Error saving to localStorage:', error);
                }
            };
            
            const loadSession = async () => {
                try {
                    // Try localStorage first (instant recovery)
                    const localSession = localStorage.getItem('mappingSession');
                    if (localSession) {
                        const session = JSON.parse(localSession);
                        if (session.inputSchema) setInputSchema(session.inputSchema);
                        if (session.outputSchema) setOutputSchema(session.outputSchema);
                        if (session.inputSchemaId) setInputSchemaId(session.inputSchemaId);
                        if (session.outputSchemaId) setOutputSchemaId(session.outputSchemaId);
                        if (session.connections) setConnections(session.connections);
                        if (session.mappingName) setMappingName(session.mappingName);
                        
                        showStatus(`‚úÖ Session recovered (${new Date(session.timestamp).toLocaleTimeString()})`, 'success');
                        setSessionLoaded(true);
                        setTimeout(updateFieldPositions, 500);
                        return;
                    }
                    
                    // Try backend session
                    const response = await fetch(`${API_URL}/session/load`);
                    const result = await response.json();
                    
                    if (result.success && result.session) {
                        const session = result.session;
                        if (session.inputSchema) setInputSchema(session.inputSchema);
                        if (session.outputSchema) setOutputSchema(session.outputSchema);
                        if (session.connections) setConnections(session.connections);
                        if (session.mappingName) setMappingName(session.mappingName);
                        
                        showStatus('‚úÖ Previous session loaded', 'success');
                        setTimeout(updateFieldPositions, 500);
                    }
                    
                    setSessionLoaded(true);
                } catch (error) {
                    console.error('Error loading session:', error);
                    setSessionLoaded(true);
                }
            };
            
            const saveSessionToBackend = async () => {
                try {
                    const session = {
                        inputSchema,
                        outputSchema,
                        connections,
                        mappingName
                    };
                    
                    const response = await fetch(`${API_URL}/session/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(session)
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        showStatus('üíæ Session saved to server', 'success');
                    }
                } catch (error) {
                    showStatus('‚ùå Error saving session', 'error');
                }
            };
            
            const clearSession = async () => {
                if (!confirm('Clear current session? This will remove all schemas and connections.')) {
                    return;
                }
                
                setInputSchema(null);
                setOutputSchema(null);
                setConnections([]);
                setMappingName('');
                setSelectedConnection(null);
                
                localStorage.removeItem('mappingSession');
                
                try {
                    await fetch(`${API_URL}/session`, { method: 'DELETE' });
                } catch (error) {
                    console.error('Error clearing backend session:', error);
                }
                
                showStatus('üóëÔ∏è Session cleared', 'success');
            };
            
            const uploadSchema = async (file, direction, type) => {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('name', file.name);
                formData.append('schema_type', type);
                formData.append('direction', direction);
                
                // Save example file content
                const fileContent = await file.text();
                if (direction === 'input') {
                    setInputExample(fileContent);
                } else {
                    setOutputExample(fileContent);
                }
                
                try {
                    const response = await fetch(`${API_URL}/schemas/upload`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        if (direction === 'input') {
                            setInputSchema(result.schema);
                        } else {
                            setOutputSchema(result.schema);
                        }
                        showStatus(`‚úÖ ${direction} schema uploaded: ${result.schema.field_count} fields`, 'success');
                        setShowUploadModal(false);
                        
                        // Calculate positions after schemas load
                        setTimeout(updateFieldPositions, 100);
                    }
                } catch (error) {
                    showStatus('‚ùå Error: ' + error.message, 'error');
                }
            };
            
            const uploadExampleFile = async (file, direction) => {
                const fileContent = await file.text();
                if (direction === 'input') {
                    setInputExample(fileContent);
                    showStatus(`‚úÖ Input example file loaded (${file.name})`, 'success');
                } else {
                    setOutputExample(fileContent);
                    showStatus(`‚úÖ Output example file loaded (${file.name})`, 'success');
                }
            };
            
            const updateFieldPositions = () => {
                const positions = {};
                const canvasEl = canvasRef.current;
                if (!canvasEl) return;
                
                const canvasRect = canvasEl.getBoundingClientRect();
                const scrollTop = canvasEl.scrollTop;
                const scrollLeft = canvasEl.scrollLeft;
                
                document.querySelectorAll('[data-field-id]').forEach(el => {
                    const rect = el.getBoundingClientRect();
                    const fieldId = el.dataset.fieldId;
                    const isInput = fieldId.startsWith('input-');
                    
                    positions[fieldId] = {
                        x: (isInput 
                            ? rect.right - canvasRect.left  // Input: dalla fine (destra) del box
                            : rect.left - canvasRect.left) + scrollLeft,   // Output: dall'inizio (sinistra) del box
                        y: rect.top - canvasRect.top + rect.height / 2 + scrollTop
                    };
                });
                setFieldPositions(positions);
            };
            
            useEffect(() => {
                let animationFrameId;
                
                const handleScroll = () => {
                    // Use requestAnimationFrame for smooth updates
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                    animationFrameId = requestAnimationFrame(updateFieldPositions);
                };
                
                window.addEventListener('resize', updateFieldPositions);
                const canvasEl = canvasRef.current;
                if (canvasEl) {
                    canvasEl.addEventListener('scroll', handleScroll, true);
                }
                return () => {
                    window.removeEventListener('resize', updateFieldPositions);
                    if (canvasEl) {
                        canvasEl.removeEventListener('scroll', handleScroll, true);
                    }
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                };
            }, []);
            
            useEffect(() => {
                if (inputSchema || outputSchema) {
                    setTimeout(updateFieldPositions, 100);
                }
            }, [inputSchema, outputSchema]);
            
            // Update positions when connections change (new arrows added)
            useEffect(() => {
                if (connections.length > 0) {
                    setTimeout(updateFieldPositions, 50);
                }
            }, [connections]);
            
            // Update positions when formula editor opens/closes (layout shifts)
            // Re-draw arrows whenever formula editor opens/closes
            useEffect(() => {
                setTimeout(updateFieldPositions, 50);
                setTimeout(updateFieldPositions, 200);
                setTimeout(updateFieldPositions, 400);
            }, [showFormulaEditor]);

            // Re-draw arrows when properties panel opens/closes (changes canvas width)
            useEffect(() => {
                setTimeout(updateFieldPositions, 50);
                setTimeout(updateFieldPositions, 200);
                setTimeout(updateFieldPositions, 400);
            }, [selectedConnection]);

            // ResizeObserver: re-draw arrows on ANY canvas size change (most robust)
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ro = new ResizeObserver(() => { updateFieldPositions(); });
                ro.observe(canvas);
                return () => ro.disconnect();
            }, []);
            
            // Update positions when sidebar is toggled (layout shifts)
            useEffect(() => {
                // Wait for the CSS transition to complete (0.3s)
                setTimeout(updateFieldPositions, 350);
            }, [showSidebar]);

            // Load available formulas from backend on mount
            useEffect(() => {
                fetch('/api/formulas')
                    .then(r => r.json())
                    .then(data => {
                        if (data.formulas && data.formulas.length > 0) {
                            setAvailableFormulas(data.formulas);
                        }
                    })
                    .catch(() => {}); // silently ignore if backend not available
            }, []);
            
            // Search function with RegExp
            const performSearch = () => {
                if (!searchQuery.trim()) {
                    setSearchResults([]);
                    setCurrentSearchIndex(-1);
                    setHighlightedField(null);
                    return;
                }
                
                const results = [];
                let regex;
                
                try {
                    // Try to create regex from search query
                    regex = new RegExp(searchQuery, 'i'); // case insensitive
                } catch (e) {
                    // If invalid regex, treat as literal string
                    regex = new RegExp(searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                }
                
                // Search in INPUT schema
                if (inputSchema && inputSchema.fields) {
                    Object.values(inputSchema.fields).forEach(field => {
                        if (regex.test(field.name) || 
                            regex.test(field.path) || 
                            regex.test(field.business_term || '') ||
                            regex.test(field.description || '')) {
                            results.push({ field, type: 'input' });
                        }
                    });
                }
                
                // Search in OUTPUT schema
                if (outputSchema && outputSchema.fields) {
                    Object.values(outputSchema.fields).forEach(field => {
                        if (regex.test(field.name) || 
                            regex.test(field.path) || 
                            regex.test(field.business_term || '') ||
                            regex.test(field.description || '')) {
                            results.push({ field, type: 'output' });
                        }
                    });
                }
                
                setSearchResults(results);
                if (results.length > 0) {
                    setCurrentSearchIndex(0);
                    scrollToField(results[0]);
                } else {
                    setCurrentSearchIndex(-1);
                    setHighlightedField(null);
                    showStatus('üîç No results found', 'error');
                }
            };
            
            const nextSearchResult = () => {
                if (searchResults.length === 0) return;
                
                const nextIndex = (currentSearchIndex + 1) % searchResults.length;
                setCurrentSearchIndex(nextIndex);
                scrollToField(searchResults[nextIndex]);
            };
            
            const scrollToField = (result) => {
                setHighlightedField(result);
                
                // Find the field element and scroll to it
                const fieldId = `${result.type}-${result.field.id}`;
                const element = document.querySelector(`[data-field-id="${fieldId}"]`);
                
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Flash highlight animation
                    element.style.transition = 'box-shadow 0.3s';
                    element.style.boxShadow = '0 0 20px 5px #ffd700';
                    setTimeout(() => {
                        element.style.boxShadow = '';
                    }, 1000);
                }
            };
            
            const addConnection = (sourceField, targetField) => {
                // Check if connection already exists
                const exists = connections.find(c => 
                    c.source === sourceField.path && c.target === targetField.path
                );
                if (exists) {
                    showStatus('‚ö†Ô∏è Connection already exists', 'error');
                    return;
                }
                
                const conn = {
                    id: `conn_${Date.now()}`,
                    source: sourceField.path,
                    target: targetField.path,
                    sourceName: sourceField.name,
                    targetName: targetField.name,
                    transformation: { type: 'direct' }
                };
                setConnections([...connections, conn]);
                showStatus(`‚úÖ Connected: ${sourceField.name} ‚Üí ${targetField.name}`, 'success');
                updateFieldPositions();
            };
            
            const deleteConnection = (connId) => {
                setConnections(connections.filter(c => c.id !== connId));
                setSelectedConnection(null);
                showStatus('üóëÔ∏è Connection deleted', 'success');
            };

            // ===== NODE FEATURES =====

            // Import a set of rows as a draggable bundle
            const handleNodeBundleImport = (rows, direction) => {
                // Normalize rows: ensure they have at least 'name' field
                const nodes = rows.map(r => ({
                    name: r.name || r.field_name || r.Field_Name || r.Name || Object.values(r)[0] || 'Unknown',
                    type: r.type || r.Type || 'string',
                    cardinality: r.cardinality || r.Cardinality || '0..1',
                    business_term: r.business_term || r.Business_Term || '',
                    description: r.description || r.Description || '',
                    required: false,
                    _raw: r
                }));
                const bundle = {
                    id: 'bundle_' + Date.now(),
                    direction,
                    nodes
                };
                setNodeBundles(prev => [...prev, bundle]);
                showStatus(`üì¶ Pacchetto creato con ${nodes.length} nodi ‚Äî trascinalo sullo schema`, 'success');
            };

            // Drop bundle after a specific field
            const handleBundleDrop = (bundle, fieldId, colType) => {
                const schema = colType === 'input' ? inputSchema : outputSchema;
                const setSchema = colType === 'input' ? setInputSchema : setOutputSchema;
                if (!schema) return;

                const fieldKey = fieldId.replace(`${colType}-`, '').replace(/_/g, '.');
                const fieldEntries = Object.entries(schema.fields);
                const dropIdx = fieldEntries.findIndex(([k]) => k === fieldKey || k.replace(/\./g,'_') === fieldKey.replace(/\./g,'_'));

                // Build new field objects
                const newFields = {};
                bundle.nodes.forEach((n, i) => {
                    const id = `imported_${Date.now()}_${i}`;
                    const path = `imported.${n.name.replace(/\s+/g,'_')}`;
                    newFields[path] = {
                        id, name: n.name, path, type: n.type,
                        cardinality: n.cardinality, business_term: n.business_term,
                        description: n.description, required: n.required,
                        xml_path: `/${schema.name || 'root'}/${n.name}`
                    };
                });

                // Insert after dropIdx
                const before = fieldEntries.slice(0, dropIdx + 1);
                const after = fieldEntries.slice(dropIdx + 1);
                const allFields = Object.fromEntries([...before, ...Object.entries(newFields), ...after]);

                setSchema({ ...schema, fields: allFields });
                setNodeBundles(prev => prev.filter(b => b.id !== bundle.id));
                showStatus(`‚úÖ ${bundle.nodes.length} nodi inseriti dopo il campo selezionato`, 'success');
                setTimeout(updateFieldPositions, 100);
            };

            // Dismiss a bundle without dropping
            const dismissBundle = (bundleId) => {
                setNodeBundles(prev => prev.filter(b => b.id !== bundleId));
            };

            // Delete a node (field) from schema + remove all connections
            const deleteNode = (field, colType) => {
                if (!window.confirm(`Eliminare il nodo "${field.name}"?\nVerranno rimossi anche tutti i collegamenti associati.`)) return;

                const schema = colType === 'input' ? inputSchema : outputSchema;
                const setSchema = colType === 'input' ? setInputSchema : setOutputSchema;
                if (!schema) return;

                // Build new fields object excluding any key that matches this field
                const newFields = {};
                Object.entries(schema.fields).forEach(([k, f]) => {
                    const isThisField = 
                        f.id === field.id ||
                        f.path === field.path ||
                        k === field.path ||
                        k === field.id;
                    if (!isThisField) {
                        newFields[k] = f;
                    }
                });

                setSchema({ ...schema, fields: newFields });

                // Remove connections involving this field
                setConnections(prev => prev.filter(c => {
                    if (colType === 'input') {
                        return c.source !== field.path && c.source !== field.id && c.source !== field.name;
                    } else {
                        return c.target !== field.path && c.target !== field.id && c.target !== field.name;
                    }
                }));

                showStatus(`üóëÔ∏è Nodo "${field.name}" eliminato con i suoi collegamenti`, 'success');
                setTimeout(updateFieldPositions, 100);
            };

            // Edit / update a node
            const saveNodeEdit = (updatedField, colType) => {
                const schema = colType === 'input' ? inputSchema : outputSchema;
                const setSchema = colType === 'input' ? setInputSchema : setOutputSchema;
                if (!schema) return;

                const newFields = {};
                Object.entries(schema.fields).forEach(([k, f]) => {
                    const isThisField =
                        f.id === updatedField.id ||
                        f.path === updatedField.path ||
                        k === updatedField.path ||
                        k === updatedField.id;
                    newFields[k] = isThisField ? { ...f, ...updatedField } : f;
                });

                setSchema({ ...schema, fields: newFields });
                showStatus(`‚úÖ Nodo "${updatedField.name}" aggiornato`, 'success');
                setTimeout(updateFieldPositions, 100);
            };

            // Open context menu on right-click of a field
            const handleFieldContextMenu = (e, field, colType) => {
                e.preventDefault();
                e.stopPropagation();
                setContextMenu({ x: e.clientX, y: e.clientY, field, colType });
            };
            
            // Expose delete callback for double-click on connections
            useEffect(() => {
                window.deleteConnectionCallback = deleteConnection;
                
                // Export functions
                window.exportMappingCSV = () => {
                    let csv = 'Source Field,Source Path,Target Field,Target Path,Transformation,Source Type,Target Type,Business Term Source,Business Term Target,Source Offset,Source Length,Source XMLPath,Target Offset,Target Length,Target XMLPath\n';
                    connections.forEach(conn => {
                        const sourceField = inputSchema?.fields?.[conn.source] || {};
                        const targetField = outputSchema?.fields?.[conn.target] || {};
                        const transformation = conn.transformation?.type || 'direct';
                        
                        csv += `"${conn.sourceName || conn.source}","${conn.source}","${conn.targetName || conn.target}","${conn.target}","${transformation}","${sourceField.type || ''}","${targetField.type || ''}","${sourceField.business_term || ''}","${targetField.business_term || ''}","${sourceField.offset || ''}","${sourceField.length || ''}","${sourceField.xml_path || ''}","${targetField.offset || ''}","${targetField.length || ''}","${targetField.xml_path || ''}"\n`;
                    });
                    
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${mappingName || 'mapping'}_export.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showStatus('üìä Mapping exported as CSV', 'success');
                };
                
                window.exportMappingJSON = () => {
                    const mappingData = {
                        name: mappingName,
                        created: new Date().toISOString(),
                        inputSchema: inputSchema?.name || 'input',
                        outputSchema: outputSchema?.name || 'output',
                        connections: connections.map(conn => ({
                            id: conn.id,
                            source: {
                                field: conn.source,
                                name: conn.sourceName,
                                path: conn.source,
                                type: inputSchema?.fields?.[conn.source]?.type,
                                businessTerm: inputSchema?.fields?.[conn.source]?.business_term,
                                offset: inputSchema?.fields?.[conn.source]?.offset,
                                length: inputSchema?.fields?.[conn.source]?.length,
                                xmlPath: inputSchema?.fields?.[conn.source]?.xml_path
                            },
                            target: {
                                field: conn.target,
                                name: conn.targetName,
                                path: conn.target,
                                type: outputSchema?.fields?.[conn.target]?.type,
                                businessTerm: outputSchema?.fields?.[conn.target]?.business_term,
                                calculation: outputSchema?.fields?.[conn.target]?.calculation,
                                offset: outputSchema?.fields?.[conn.target]?.offset,
                                length: outputSchema?.fields?.[conn.target]?.length,
                                xmlPath: outputSchema?.fields?.[conn.target]?.xml_path
                            },
                            transformation: conn.transformation
                        }))
                    };
                    
                    const blob = new Blob([JSON.stringify(mappingData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${mappingName || 'mapping'}_export.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showStatus('üìÑ Mapping exported as JSON', 'success');
                };
                
                return () => {
                    delete window.deleteConnectionCallback;
                    delete window.exportMappingCSV;
                    delete window.exportMappingJSON;
                };
            }, [connections, mappingName, inputSchema, outputSchema]);
            
            // Project Management: Save Project
            const saveProject = () => {
                if (!mappingName) {
                    showStatus('‚ö†Ô∏è Enter project name first', 'error');
                    return;
                }
                
                const project = {
                    projectName: mappingName,
                    version: '2.0', // Updated to 2.0 with schema definitions
                    created: new Date().toISOString(),
                    inputSchema: inputSchema,
                    outputSchema: outputSchema,
                    inputSchemaId: inputSchemaId, // Schema ID for backend reference
                    outputSchemaId: outputSchemaId, // Schema ID for backend reference
                    inputSchemaDefinition: inputSchemaDefinition, // Schema Editor definition
                    outputSchemaDefinition: outputSchemaDefinition, // Schema Editor definition
                    inputExample: inputExample,
                    outputExample: outputExample,
                    connections: connections
                };
                
                const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${mappingName}_project.json`;
                a.click();
                URL.revokeObjectURL(url);
                showStatus('üì¶ Project saved with schema definitions!', 'success');
            };
            
            // Project Management: Load Project
            const loadProject = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        const text = await file.text();
                        const project = JSON.parse(text);
                        
                        // Validate project structure
                        if (!project.projectName || !project.inputSchema || !project.outputSchema) {
                            showStatus('‚ö†Ô∏è Invalid project file', 'error');
                            return;
                        }
                        
                        // Load all data
                        setMappingName(project.projectName);
                        setInputSchema(project.inputSchema);
                        setOutputSchema(project.outputSchema);
                        setInputSchemaId(project.inputSchemaId || ''); // Load schema IDs
                        setOutputSchemaId(project.outputSchemaId || ''); // Load schema IDs
                        setInputSchemaDefinition(project.inputSchemaDefinition || null);
                        setOutputSchemaDefinition(project.outputSchemaDefinition || null);
                        setInputExample(project.inputExample || '');
                        setOutputExample(project.outputExample || '');
                        setConnections(project.connections || []);
                        
                        // Update field positions after schemas load
                        setTimeout(() => {
                            updateFieldPositions();
                            const hasDefinitions = project.inputSchemaDefinition || project.outputSchemaDefinition;
                            const msg = hasDefinitions 
                                ? `üì¶ Project "${project.projectName}" loaded with schema definitions!`
                                : `üì¶ Project "${project.projectName}" loaded!`;
                            showStatus(msg, 'success');
                        }, 500);
                        
                    } catch (err) {
                        console.error('Load project error:', err);
                        showStatus('‚ùå Failed to load project: ' + err.message, 'error');
                    }
                };
                
                input.click();
            };
            
            // Reverse Mapping Function
            const reverseMapping = async () => {
                if (!inputSchema || !outputSchema || connections.length === 0) {
                    showStatus('‚ö†Ô∏è Load schemas and create mappings first', 'error');
                    return;
                }
                
                const confirm = window.confirm(
                    'üîÑ REVERSE MAPPING\n\n' +
                    'This will:\n' +
                    '‚Ä¢ Swap Input ‚Üî Output schemas\n' +
                    '‚Ä¢ Reverse all connections\n' +
                    '‚Ä¢ Invert transformations where possible\n\n' +
                    'Non-invertible transformations (TRIM, CASE, SUBSTR) will be converted to direct mappings.\n\n' +
                    'Continue?'
                );
                
                if (!confirm) return;
                
                try {
                    showStatus('üîÑ Reversing mapping...', 'info');
                    
                    // Prepare project data
                    const project = {
                        projectName: mappingName || 'Untitled',
                        version: '1.0',
                        created: new Date().toISOString(),
                        inputSchema: inputSchema,
                        outputSchema: outputSchema,
                        inputExample: inputExample,
                        outputExample: outputExample,
                        connections: connections
                    };
                    
                    // Call backend
                    const response = await fetch('http://localhost:8080/api/mapping/reverse', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ project })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Reverse failed');
                    }
                    
                    const data = await response.json();
                    const reversed = data.reversed_project;
                    const report = data.report;
                    
                    // Apply reversed mapping
                    setInputSchema(reversed.inputSchema);
                    setOutputSchema(reversed.outputSchema);
                    // SWAP schema IDs when reversing!
                    setInputSchemaId(outputSchemaId);  // Input becomes Output's ID
                    setOutputSchemaId(inputSchemaId);  // Output becomes Input's ID
                    setInputExample(reversed.inputExample || '');
                    setOutputExample(reversed.outputExample || '');
                    setConnections(reversed.connections || []);
                    setMappingName(reversed.projectName);
                    
                    // Update UI
                    setTimeout(() => {
                        updateFieldPositions();
                    }, 500);
                    
                    // Show report
                    if (report.total_warnings > 0) {
                        let warningMsg = `‚ö†Ô∏è Reversed with ${report.total_warnings} warning(s):\n\n`;
                        report.warnings.slice(0, 5).forEach(w => {
                            warningMsg += `‚Ä¢ ${w.source} ‚Üí ${w.target}\n  ${w.reason}\n\n`;
                        });
                        if (report.warnings.length > 5) {
                            warningMsg += `... and ${report.warnings.length - 5} more`;
                        }
                        alert(warningMsg);
                    }
                    
                    showStatus(`üîÑ Mapping reversed! ${reversed.connections.length} connections inverted`, 'success');
                    
                } catch (err) {
                    console.error('Reverse error:', err);
                    showStatus('‚ùå Failed to reverse mapping: ' + err.message, 'error');
                }
            };
            
            const updateConnectionTransformation = (connId, transformation) => {
                setConnections(connections.map(c => 
                    c.id === connId ? { ...c, transformation } : c
                ));
                showStatus('‚úÖ Transformation updated', 'success');
            };
            
            const saveMapping = async () => {
                if (!mappingName || connections.length === 0) {
                    showStatus('‚ö†Ô∏è Enter name and add connections', 'error');
                    return;
                }
                
                try {
                    const response = await fetch(`${API_URL}/mappings`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: mappingName,
                            input_schema: inputSchema?.name || 'input',
                            output_schema: outputSchema?.name || 'output',
                            rules: connections.map(c => ({
                                id: c.id,
                                source: c.source,
                                target: c.target,
                                transformation: c.transformation,
                                enabled: true
                            }))
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        showStatus('‚úÖ Mapping saved!', 'success');
                    }
                } catch (error) {
                    showStatus('‚ùå Save error', 'error');
                }
            };
            

            // Export current fields as CSV (always from live state, not backend)
            const exportFieldsCSV = (direction) => {
                const schema = direction === 'input' ? inputSchema : outputSchema;
                if (!schema || !schema.fields) {
                    showStatus('‚ö†Ô∏è Nessuno schema caricato', 'error');
                    return;
                }
                const fields = Object.values(schema.fields);
                if (fields.length === 0) {
                    showStatus('‚ö†Ô∏è Nessun campo da esportare', 'error');
                    return;
                }

                // Detect columns dynamically from all fields
                const allKeys = new Set(['campo', 'business_term', 'spiegazione', 'obbligatorio', 'numerosit√†', 'condizionalit√†']);
                fields.forEach(f => {
                    if (f.type)          allKeys.add('type');
                    if (f.xml_path)      allKeys.add('xml_path');
                    if (f.json_path)     allKeys.add('json_path');
                    if (f.offset)        allKeys.add('offset');
                    if (f.length)        allKeys.add('length');
                    if (f.calculation)   allKeys.add('calculation');
                    if (f.condition)     allKeys.add('condizionalit√†');
                });
                const headers = Array.from(allKeys);

                const rows = fields.map(f => headers.map(h => {
                    switch(h) {
                        case 'campo':          return f.path || f.name || '';
                        case 'business_term':  return f.business_term || '';
                        case 'spiegazione':    return f.description || '';
                        case 'obbligatorio':   return f.required ? 'SI' : 'NO';
                        case 'numerosit√†':     return f.cardinality || '0..1';
                        case 'condizionalit√†': return f.condition || '';
                        case 'type':           return f.type || '';
                        case 'xml_path':       return f.xml_path || '';
                        case 'json_path':      return f.json_path || '';
                        case 'offset':         return f.offset || '';
                        case 'length':         return f.length || '';
                        case 'calculation':    return f.calculation || '';
                        default:               return f[h] || '';
                    }
                }));

                const escape = v => '"' + String(v).replace(/"/g, '""') + '"';
                const csv = [headers.map(escape), ...rows.map(r => r.map(escape))].join('\n');
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (schema.name || direction + '_schema') + '_fields.csv';
                a.click();
                URL.revokeObjectURL(url);
                showStatus('‚úÖ Export completato: ' + fields.length + ' campi', 'success');
            };

            const exportDiagram = async () => {
                if (!connections || connections.length === 0) {
                    showStatus('‚ö†Ô∏è Nessuna connessione da esportare', 'error');
                    return;
                }
                try {
                    showStatus('üé® Generazione diagramma...', 'info');
                    const res = await fetch(`${API_URL}/mapping/diagram`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
                        body: JSON.stringify({
                            connections: connections,
                            projectName: mappingName || 'Mappatura',
                            inputSchemaName: inputSchemaId || 'Input',
                            outputSchemaName: outputSchemaId || 'Output'
                        })
                    });
                    if (!res.ok) throw new Error(await res.text());
                    const blob = await res.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'mapping_diagram.svg';
                    a.click();
                    window.URL.revokeObjectURL(url);
                    showStatus('‚úÖ Diagramma esportato!', 'success');
                } catch(e) {
                    showStatus('‚ùå Errore: ' + e.message, 'error');
                }
            };

            const downloadSampleCSV = async (type) => {
                try {
                    const response = await fetch(`${API_URL}/csv/sample/${type}`);
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sample_${type}.csv`;
                    a.click();
                    showStatus(`‚úÖ Downloaded sample ${type} CSV`, 'success');
                } catch (error) {
                    showStatus('‚ùå Download error', 'error');
                }
            };
            
            // AI Auto-Map Function
            const runAIAutoMap = async () => {
                if (!inputSchema || !outputSchema) {
                    showStatus('‚ö†Ô∏è Load input and output schemas first', 'error');
                    return;
                }
                
                setAiProcessing(true);
                setShowAiPanel(true);
                showStatus('ü§ñ AI analyzing schemas...', 'success');
                
                try {
                    // Prepare schema data
                    const inputFields = Object.values(inputSchema.fields || {}).map(f => ({
                        name: f.name,
                        path: f.path,
                        type: f.type,
                        business_term: f.business_term,
                        description: f.description,
                        cardinality: f.cardinality
                    }));
                    
                    const outputFields = Object.values(outputSchema.fields || {}).map(f => ({
                        name: f.name,
                        path: f.path,
                        type: f.type,
                        business_term: f.business_term,
                        description: f.description,
                        cardinality: f.cardinality,
                        calculation: f.calculation
                    }));
                    
                    // Prepare example data (first 10 lines)
                    const inputSample = inputExample ? inputExample.split('\n').slice(0, 10).join('\n') : '';
                    const outputSample = outputExample ? outputExample.split('\n').slice(0, 10).join('\n') : '';
                    
                    // Try Claude first, fallback to OpenAI
                    let suggestions = [];
                    
                    // Call backend instead of direct API
                    const response = await fetch(`${API_URL}/ai/auto-map`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            input_fields: inputFields,
                            output_fields: outputFields,
                            input_sample: inputSample,
                            output_sample: outputSample
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Backend AI error');
                    }
                    
                    suggestions = await response.json();
                    
                    setAiSuggestions(suggestions);
                    showStatus(`‚úÖ AI found ${suggestions.length} suggestions`, 'success');
                    
                } catch (error) {
                    console.error('AI Error:', error);
                    showStatus('‚ùå AI error: ' + error.message, 'error');
                } finally {
                    setAiProcessing(false);
                }
            };
            
            
            // AI Assist for single field
            const runAIAssist = async (outputField) => {
                setSelectedOutputField(outputField);
                setAiProcessing(true);
                setShowAiPanel(true);
                
                // This would call AI for just this one field
                // For now, trigger auto-map and filter
                await runAIAutoMap();
            };
            
            // Business Rules Automap - Match by identical business_term
            const runBusinessRulesAutomap = () => {
                if (!inputSchema || !outputSchema) {
                    showStatus('‚ö†Ô∏è Load input and output schemas first', 'error');
                    return;
                }
                
                const suggestions = [];
                const inputFields = Object.values(inputSchema.fields || {});
                const outputFields = Object.values(outputSchema.fields || {});
                
                // Find matches based on business_term
                outputFields.forEach(outField => {
                    const outBusinessTerm = (outField.business_term || '').trim().toLowerCase();
                    
                    // Skip if no business term
                    if (!outBusinessTerm) return;
                    
                    // Find input fields with matching business term
                    inputFields.forEach(inField => {
                        const inBusinessTerm = (inField.business_term || '').trim().toLowerCase();
                        
                        if (inBusinessTerm && inBusinessTerm === outBusinessTerm) {
                            // Check if connection already exists
                            const exists = connections.find(c => 
                                c.source === inField.path && c.target === outField.path
                            );
                            
                            if (!exists) {
                                suggestions.push({
                                    source_field: inField.path,
                                    target_field: outField.path,
                                    confidence: 100, // Perfect match!
                                    reasoning: `Exact match on business term: "${outField.business_term}"`,
                                    suggested_formula: null
                                });
                            }
                        }
                    });
                });
                
                if (suggestions.length > 0) {
                    setAiSuggestions(suggestions);
                    setShowAiPanel(true);
                    showStatus(`üìã Found ${suggestions.length} business rule match(es)!`, 'success');
                } else {
                    showStatus('‚ÑπÔ∏è No matching business terms found', 'info');
                }
            };
            
            // Approve AI suggestion
            const approveAISuggestion = (suggestion) => {
                console.log('üîµ APPROVE CALLED:', suggestion.source_field, '‚Üí', suggestion.target_field);
                
                const sourceField = Object.values(inputSchema.fields).find(f => f.path === suggestion.source_field);
                const targetField = Object.values(outputSchema.fields).find(f => f.path === suggestion.target_field);
                
                if (sourceField && targetField) {
                    const conn = {
                        id: `conn_${Date.now()}`,
                        source: sourceField.path,
                        target: targetField.path,
                        sourceName: sourceField.name,
                        targetName: targetField.name,
                        transformation: suggestion.suggested_formula 
                            ? { type: 'formula', formula: suggestion.suggested_formula }
                            : { type: 'direct' }
                    };
                    
                    console.log('  ‚úÖ Connection created:', conn.id);
                    setConnections(prev => [...prev, conn]);
                    
                    // CRITICAL: Use functional update to get current state
                    setAiSuggestions(prevSuggestions => {
                        const newSuggestions = prevSuggestions.filter(s => 
                            !(s.source_field === suggestion.source_field && 
                              s.target_field === suggestion.target_field)
                        );
                        console.log('  üìâ Suggestions:', prevSuggestions.length, '‚Üí', newSuggestions.length);
                        return newSuggestions;
                    });
                    
                    showStatus(`‚úÖ Applied: ${sourceField.name} ‚Üí ${targetField.name}`, 'success');
                    setTimeout(updateFieldPositions, 50);
                } else {
                    console.error('  ‚ùå Field not found!', {
                        sourceField: suggestion.source_field,
                        targetField: suggestion.target_field,
                        foundSource: !!sourceField,
                        foundTarget: !!targetField
                    });
                }
            };
            
            // Reject AI suggestion
            const rejectAISuggestion = (suggestion) => {
                // Filter by content not reference
                setAiSuggestions(aiSuggestions.filter(s => 
                    !(s.source_field === suggestion.source_field && s.target_field === suggestion.target_field)
                ));
            };
            
            return React.createElement('div', { className: 'app-container' },
                // Sidebar toggle button
                React.createElement('button', {
                    className: 'sidebar-toggle',
                    onClick: () => setShowSidebar(!showSidebar),
                    title: showSidebar ? 'Hide sidebar' : 'Show sidebar'
                }, showSidebar ? '‚àí' : '+'),
                
                // Sidebar wrapper with collapse
                React.createElement('div', { 
                    className: `sidebar-wrapper ${showSidebar ? '' : 'collapsed'}`,
                    style: {
                        width: showSidebar ? '350px' : '0',
                        overflow: 'hidden',
                        transition: 'width 0.3s ease'
                    }
                },
                    React.createElement(Sidebar, {
                    inputSchema,
                    outputSchema,
                    connections,
                    activeTab,
                    setActiveTab,
                    setShowUploadModal,
                    setUploadDirection,
                    downloadSampleCSV,
                    exportFieldsCSV,
                    statusMessage,
                    setDraggedField,
                    selectedConnection,
                    setSelectedConnection,
                    uploadExampleFile,
                    inputExample,
                    outputExample,
                    loadAvailableSchemas,
                    showStatus,
                    availableInputSchemas,
                    availableOutputSchemas,
                    inputSchemaId,
                    setInputSchemaId,
                    outputSchemaId,
                    setOutputSchemaId,
                    exportDiagram
                })
                ),  // Close sidebar-wrapper
                
                React.createElement(MainCanvas, {
                    inputSchema,
                    outputSchema,
                    connections,
                    draggedField,
                    setDraggedField,
                    addConnection,
                    mappingName,
                    setMappingName,
                    saveMapping,
                    canvasRef,
                    fieldPositions,
                    updateFieldPositions,
                    selectedConnection,
                    setSelectedConnection,
                    saveSessionToBackend,
                    clearSession,
                    sessionLoaded,
                    inputExample,
                    outputExample,
                    hoverPopup,
                    setHoverPopup,
                    hoverTimeoutRef,
                    setShowFormulaEditor,
                    setEditingConnection,
                    runAIAutoMap,
                    runBusinessRulesAutomap,
                    aiProcessing,
                    setShowSettings,
                    searchQuery,
                    setSearchQuery,
                    performSearch,
                    nextSearchResult,
                    searchResults,
                    currentSearchIndex,
                    saveProject,
                    loadProject,
                    reverseMapping,
                    setPopupPinned,
                    popupPinned,
                    setShowSchemaEditor,
                    hideConnected,
                    setHideConnected,
                    onOpenNodeImport: (dir) => { setNodeImportDirection(dir); setShowNodeImportModal(true); },
                    onFieldContextMenu: handleFieldContextMenu,
                    onEditNode: (f, t) => setEditingNode({ field: f, colType: t }),
                    onDeleteNode: deleteNode,
                    exportDiagram
                }),
                
                selectedConnection && React.createElement(PropertiesPanel, {
                    connection: selectedConnection,
                    availableFormulas: availableFormulas,
                    updateConnectionTransformation,
                    deleteConnection,
                    setSelectedConnection,
                    setShowFormulaEditor,
                    setEditingConnection
                }),
                
                showUploadModal && React.createElement(UploadModal, {
                    direction: uploadDirection,
                    onClose: () => setShowUploadModal(false),
                    onUpload: uploadSchema
                }),

                // Node import modal
                showNodeImportModal && React.createElement(NodeImportModal, {
                    direction: nodeImportDirection,
                    schemaType: nodeImportDirection === 'input'
                        ? (inputSchema?.type || (inputSchema?.name?.includes('xml') ? 'xml' : 'csv'))
                        : (outputSchema?.type || (outputSchema?.name?.includes('xml') ? 'xml' : 'csv')),
                    onClose: () => setShowNodeImportModal(false),
                    onImport: handleNodeBundleImport
                }),

                // Draggable node bundles
                nodeBundles.map(bundle =>
                    React.createElement(NodeBundle, {
                        key: bundle.id,
                        bundle,
                        onDrop: handleBundleDrop,
                        onDismiss: dismissBundle
                    })
                ),

                // Field context menu
                contextMenu && React.createElement(FieldContextMenu, {
                    x: contextMenu.x,
                    y: contextMenu.y,
                    field: contextMenu.field,
                    colType: contextMenu.colType,
                    onEdit: (field, colType) => setEditingNode({ field, colType }),
                    onDelete: deleteNode,
                    onClose: () => setContextMenu(null)
                }),

                // Node edit modal
                editingNode && React.createElement(NodeEditModal, {
                    field: editingNode.field,
                    colType: editingNode.colType,
                    onSave: saveNodeEdit,
                    onClose: () => setEditingNode(null)
                }),
                
                hoverPopup && React.createElement(HoverPopup, { 
                    popup: hoverPopup,
                    setPopupPinned,
                    setHoverPopup
                }),
                
                showFormulaEditor && editingConnection && React.createElement(FormulaEditor, {
                    connection: editingConnection,
                    onSave: (result) => {
                        // result is { type: 'CUSTOM', expression: '...' }
                        updateConnectionTransformation(editingConnection.id, result);
                        setShowFormulaEditor(false);
                        setEditingConnection(null);
                    },
                    onClose: () => {
                        setShowFormulaEditor(false);
                        setEditingConnection(null);
                    }
                }),
                
                showSettings && React.createElement(SettingsModal, {
                    onClose: () => setShowSettings(false)
                }),
                
                showSchemaEditor && React.createElement(SchemaEditorModal, {
                    show: showSchemaEditor,
                    onClose: () => setShowSchemaEditor(false),
                    onSchemaSelect: (schema, direction, definition) => {
                        if (direction === 'input') {
                            setInputSchema(schema);
                            setInputSchemaDefinition(definition);
                            showStatus('‚úÖ Schema set as Input!', 'success');
                        } else {
                            setOutputSchema(schema);
                            setOutputSchemaDefinition(definition);
                            showStatus('‚úÖ Schema set as Output!', 'success');
                        }
                        setTimeout(updateFieldPositions, 300);
                    }
                }),
                
                showAiPanel && React.createElement(AISuggestionsPanel, {
                    suggestions: aiSuggestions,
                    onApprove: approveAISuggestion,
                    onReject: rejectAISuggestion,
                    onClose: () => setShowAiPanel(false),
                    processing: aiProcessing
                })
            );
        }
        
        function Sidebar({ inputSchema, outputSchema, connections, activeTab, setActiveTab, setShowUploadModal, setUploadDirection, downloadSampleCSV, exportFieldsCSV, statusMessage, setDraggedField, selectedConnection, setSelectedConnection, uploadExampleFile, inputExample, outputExample, loadAvailableSchemas, showStatus, availableInputSchemas, availableOutputSchemas, inputSchemaId, setInputSchemaId, outputSchemaId, setOutputSchemaId, exportDiagram }) {
            return React.createElement('div', { className: 'sidebar' },
                React.createElement('div', { className: 'sidebar-header' },
                    React.createElement('div', { style: { textAlign: 'center', paddingBottom: '0', marginTop: '-18px' } },
                        React.createElement('img', {
                            src: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iMTUzNi4wMDAwMDBwdCIgaGVpZ2h0PSIxMDI0LjAwMDAwMHB0IiB2aWV3Qm94PSIwIDAgMTUzNi4wMDAwMDAgMTAyNC4wMDAwMDAiCiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCBtZWV0Ij4KCjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLDEwMjQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNMzc2MyA3MjUzIGMxNSAtMiAzOSAtMiA1NSAwIDE1IDIgMiA0IC0yOCA0IC0zMCAwIC00MyAtMiAtMjcgLTR6Ii8+CjxwYXRoIGQ9Ik0zOTk4IDcyNTMgYzE4IC0yIDQ1IC0yIDYwIDAgMTUgMiAwIDQgLTMzIDQgLTMzIDAgLTQ1IC0yIC0yNyAtNHoiLz4KPHBhdGggZD0iTTM1NDUgNzIzMCBjLTIzOCAtNDcgLTQ0MCAtMTQzIC02NjAgLTMxMSAtOTQgLTcxIC0yNDAgLTI1MCAtMjk2Ci0zNjEgLTY1IC0xMjggLTExNSAtMzI4IC0xMjAgLTQ4MCAtMiAtMzQgLTcgLTU5IC0xNCAtNjIgLTcgLTIgLTkyIC04IC0xOTAKLTEyIC0xMDEgLTQgLTE3MSAtMTAgLTE2MyAtMTUgMjMgLTE1IDI3OCAtOTcgNDE2IC0xMzMgMjQwIC02NSA2NjQgLTE1NiA3MjIKLTE1NiAxMiAwIDE3IDExIDE5IDQ3IDEgMjYgNCA1MCA2IDUzIDMgNCAtNTEgMjIgLTExOCA0MSBsLTEyMiAzNCA5NiAzIDk2IDMKMTcgNzcgYzEwIDQyIDIxIDg1IDI3IDk0IDE1IDI5IDEyIDM2IC02NCAxMTcgLTgxIDg2IC0xNTkgMjA5IC0yMDIgMzE2IC0zNwo5NCAtOTYgMjY4IC05MSAyNzIgMiAyIDE4IC0zOCAzNiAtODkgODAgLTIyMyAxNjEgLTM0MSAzMzkgLTQ5MiBsODggLTc1IDcKLTE0MiBjNiAtMTI1IDkgLTE0NSAyNyAtMTYyIGwyMCAtMTkgLTEgMTU0IGMtMSA4NCAtMSAxNTggMCAxNjMgMCA2IDE2NyAtMTU5CjM3MSAtMzY1IGwzNzEgLTM3NSAtMTE5IC0xMTQgYy0xNjUgLTE1OCAtNjA1IC01NzQgLTY4MSAtNjQzIC01NiAtNTIgLTk0IC03NQotNzcgLTQ4IDMgNSAyNCA5OCA0NSAyMDUgMzAgMTQ3IDM3IDIwMSAzMCAyMTYgLTYgMTAgLTE0IDE5IC0xOSAxOSAtMTggMAotMjc1IC03NCAtNDM5IC0xMjYgLTI3OSAtOTAgLTY4OCAtMjYxIC02NjkgLTI4MCAyIC0zIDc4IDExIDE2OCAzMCA5MCAxOSAxNjUKMzMgMTY3IDMxIDIgLTIgMTkgLTY2IDM4IC0xNDIgNzQgLTI5NiA5OSAtMzUwIDIzMCAtNDk4IGw2MiAtNzAgNyAtMTM4IGM4Ci0xNDggMTIgLTE1OCA4MCAtMjIwIDk4IC04OSA1MTMgLTMxMyA2NzYgLTM2NSAyNTUgLTgyIDQyNyAtNzQgNjg1IDI4IDEyMSA0OQo0MjggMjExIDU0MiAyODcgMTI1IDgzIDEyOSA5MyAxMzQgMjkzIGw0IDE2NSA1MiA2NSBjMjkgMzUgNjEgODMgNzIgMTA2IDIxCjQzIDYwIDIwMSA4MyAzMzkgbDEzIDgwIDUwIDUgYzk3IDExIDEzNyA1MCAyMDkgMjAzIDczIDE1NiAxMTUgMzczIDExNSA1OTUgMAoxNjAgLTE4IDI0NyAtNTkgMjg3IC0xNiAxNCAtNTggMzcgLTk2IDQ5IC0zNyAxMyAtNzEgMjggLTc1IDMzIC0yMiAyMyAtNDIKMTM2IC00NSAyNTIgLTMgMTEyIC0zMyAzMTMgLTUwIDMyOSAtOCA4IC02IC01IDEwIC05OCA4IC00NyAxOCAtMTQyIDIyIC0yMTMKNSAtMTA2IDQgLTEzMCAtOSAtMTQ1IC05IC05IC0zNCAtNTEgLTU4IC05MiAtMjMgLTQxIC0zOSAtNjYgLTM1IC01NSA0IDExIDkKMzggMTIgNjAgNyA2MSAtMTQgMzQ0IC0zMCAzOTcgLTE1IDQ2IC0xNCA0OCAyMiAxMjAgMjAgNDAgMzkgNzQgNDMgNzYgNCAyIDQKMTAgMSAxOCAtMyA4IC0xOCAtMTIgLTM5IC01NCAtNDEgLTgyIC0xMDQgLTE5MCAtMTA0IC0xNzkgMCA0IDkgMjUgMjAgNDcgMTEKMjIgMjAgNDcgMjAgNTcgMCA0MCAtOTkgMjE4IC0xNTIgMjc0IC0yOSAzMCAtNzAgNzQgLTkwIDk3IGwtMzcgNDEgLTQ0IC0xMzcKYy02OCAtMjA3IC03NCAtMjM4IC01NSAtMjU5IDU1IC02MiAxMTMgLTI5NyA5MCAtMzYyIC0xMCAtMjcgLTggLTMwIDMxIC00NwoyMyAtMTEgNjIgLTM3IDg3IC01OCA0MyAtMzcgNDUgLTM4IDQ4IC0xNyAyIDEyIDkgMjAgMTUgMTggMTggLTYgMTI4IC0yMjMKMTIyIC0yMzkgLTEzIC0zMyAtNTYgLTcgLTExMCA2NiAtNTMgNzIgLTkwIDEwOSAtMTM1IDEzOSAtNDggMzMgLTIzNSAxNyAtNDcyCi0zOSAtMTIzIC0yOSAtMTYxIC01MSAtMjAzIC0xMTYgLTE2IC0yNiAtMzMgLTQ3IC0zNyAtNDcgLTUgLTEgLTM1IDI2IC02OCA1OQotMzMgMzMgLTYwIDU1IC02MCA0OCAwIC02IC0zIC04IC02IC01IC05IDggMjMgOTQgNDggMTI5IDMxIDQ0IDIwMiAxNTEgMzQyCjIxNCAxMzIgNTkgMTg2IDk2IDIxMCAxNDMgOCAxNCA2NCAxODEgMTI2IDM3MSBsMTEyIDM0NSAtNDUgNDAgYy00MyAzNyAtMTA3CjgxIC0xMDcgNzIgMCAtMyAyNSAtMjEgOTggLTczIDIgLTEgLTQgLTE3IC0xMiAtMzUgLTggLTE5IC0xNSAtMjkgLTE1IC0yMiAtMQo3IC0zMCAzMiAtNjUgNTggLTM1IDI1IC02OSA1MSAtNzYgNTkgLTIxIDI2IC0yOTMgMTUzIC0zOTQgMTg1IC05MyAyOSAtMTYwCjQxIC0zMzMgNTkgLTcyIDggLTcyIDggLTc3IC0xNyAtMyAtMTQgLTI4IC0xNzIgLTU2IC0zNTEgLTI4IC0xNzkgLTYyIC0zOTAKLTc1IC00NzAgLTE0IC04MCAtMjUgLTE3NyAtMjUgLTIxNiAwIC02NSA0IC04MCA0OSAtMTcwIDU0IC0xMDkgNzEgLTE2MSA3MQotMjE1IDAgLTM0IC0yIC0zNiAtMjYgLTMxIC0xNSAzIC0zMyAxNyAtNDIgMzEgLTggMTQgLTUxIDU4IC05NSA5NiAtNDMgMzkKLTEzNSAxMjUgLTIwMyAxOTEgLTY4IDY3IC0xMjQgMTE4IC0xMjYgMTEzIC01IC0xMyAtMTcyIDE0NSAtMjEzIDIwMSAtMzMgNDUKLTg0IDE0MCAtMTA2IDE5OCAtMTYgNDMgMCAyMSAzNiAtNDcgNDEgLTc3IDEzOCAtMjAxIDE1OSAtMjAxIDcgMCAxOSAxNCAyNgozMCAyNSA2MCAxMzQgMTUyIDMwOCAyNTggNTUgMzMgMTM0IDU1IDE0MyA0MCA5IC0xNCAxMCAtMTAgNDQgMTcyIDM5IDIxNSA2NwozOTIgNjEgMzk4IC0zIDMgLTYzIC0zIC0xMzMgLTEzIC0xODcgLTI2IC00MjcgLTEwOSAtNTUwIC0xOTEgLTY2IC00NCAtMTYzCi0xMjEgLTE4MCAtMTQzIC0xNCAtMjAgLTIxIC0xMyAtMjggMjUgLTUgMjcgLTEgMzIgNzAgNzcgMTkxIDEyMiA0MDIgMjA0IDYwNQoyMzcgODUgMTMgMTAyIDE4IDY1IDE4IC0yNyAwIC05MCAtOCAtMTQwIC0xOHogbS02OTYgLTQyNCBjMzggLTYwIDMwIC03OSAtNzEKLTE4MiAtOTAgLTkyIC0xMTkgLTEwOSAtMTQ1IC04MyAtMTcgMTcgMjkgMTExIDk1IDE5NyA0NiA2MCA4NiAxMDIgOTggMTAyIDEKMCAxMiAtMTUgMjMgLTM0eiBtMTUxMSAtOTggYzEwMSAtMzEgMTk1IC0xMDQgMzA3IC0yNDIgbDMyIC00MCAxMiAzMCBjNiAxNgoyOSA3NiA1MCAxMzQgMjEgNTggMzggMTAxIDM4IDk3IDIgLTE3IC0xMzEgLTQ3MiAtMTQ1IC00OTggLTIxIC00MSAtNjQgLTcwCi0yMDQgLTEzNiAtMTM3IC02NSAtMjkyIC0xNTggLTMyOCAtMTk2IC0xMiAtMTMgLTM2IC01NSAtNTIgLTkzIC0yNiAtNTkgLTI5Ci02MyAtMjQgLTI5IDQgMjIgMTMgNTcgMjAgNzkgMTggNTEgMTggNjMgLTUgODggLTExIDExIC0yOCA0MyAtMzkgNzIgLTExIDI4Ci0zNyA5NCAtNTcgMTQ2IC00OSAxMjYgLTU3IDIyMSAtMjYgMzMzIDM4IDE0MSA4MSAyMDYgMTU1IDIzOCA4NyAzNyAxODEgNDMKMjY2IDE3eiBtLTE3ODggLTI1MyBjLTIgLTE0IC04IC0yNSAtMTMgLTI1IC0xMiAwIC0xMSA3IDEgMzEgMTQgMjYgMTggMjQgMTIKLTZ6IG0tMzYgLTIwNSBjLTkgLTU4IC0yMSAtMTM4IC0yOCAtMTc3IC02IC00MyAtMTYgLTczIC0yMyAtNzMgLTcgMCAtMTAgMTEKLTkgMjggMiAxNSA4IDcyIDE0IDEyNyAxMyAxMTkgNTMgMjc3IDU4IDIzMCAyIC0xNiAtMyAtNzcgLTEyIC0xMzV6IG0yODEyCi00MjUgYzE0IC01NCAxNSAtODggMyAtMTAwIC0yMyAtMjQgLTg0IC0yMzMgLTEwNCAtMzU1IC0yIC0xNCAtNSAtNSAtNiAyMCAwCjI1IDE1IDEwNCAzNSAxNzUgMTkgNzIgMzcgMTQyIDQwIDE1NiA3IDMzIC0xMyA0NyAtMzEgMjMgLTggLTExIC0xNSAtMTQgLTE1Ci03IDAgMTcgNTEgMTMzIDU5IDEzMyA0IDAgMTIgLTIwIDE5IC00NXogbS00MzkgLTE1MiBjMjEgLTUgMjAgLTcgLTE1IC0yMAotNDggLTE4IC0zMTQgLTMwIC0yNzQgLTEyIDY2IDI5IDIzMyA0NyAyODkgMzJ6IG02MTkgLTEzOCBjLTExIC0zMyAtMzMgLTExOAotNDggLTE5MCAtMjQgLTExMiAtMjggLTEyMyAtMjkgLTgwIC0xIDU1IDAgNTQgLTc0IDU3IGwtMjggMSA2IDY4IGM2IDYyIDQyCjIxMiA0NCAxODIgMSAtNyAxMCAtMTMgMjEgLTEzIDEyIDAgMzQgLTcgNTAgLTE1IDI4IC0xNCAyOSAtMTQgNTAgMjEgMTEgMjAKMjMgMzUgMjUgMzMgMiAtMiAtNiAtMzEgLTE3IC02NHogbS03ODIgNDQgYzUzIC0xNCA2NCAtNDMgMTIgLTMxIC01MiAxMSAtMTc5CjcgLTIyMyAtOCAtMjIgLTggLTQ0IC0xMyAtNDggLTEyIC01IDEgLTYgLTIgLTIgLTcgMyAtNiAtMyAtMTUgLTE0IC0yMSAtMTEKLTUgLTIyIC02IC0yNSAtMSAtOSAxMyAyNCAzNyA4OSA2NSA2NiAyOCAxMzggMzMgMjExIDE1eiBtNTk5IC05MSBjLTEwIC02OQotMjIgLTEwMSAtMzYgLTkyIC0yMSAxMyAxMiAxNDQgMzcgMTQ0IDMgMCAzIC0yNCAtMSAtNTJ6IG0tNjM1IC0xOCBjMTAgLTUgMjUKLTI4IDM0IC01MSAxNSAtMzcgMTUgLTQ0IDEgLTY1IC0yNiAtNDAgLTEzNSAtNDUgLTE3NiAtOCAtMjYgMjMgLTI3IDEwOSAtMgoxMjIgMjIgMTMgMTIxIDE0IDE0MyAyeiBtLTMxMSAtMjkgYy04IC0xMCAtMjcgLTM1IC00MyAtNTYgLTUxIC02MyAtNDEgLTY3CjE4OSAtNzEgMTQyIC0zIDIxOSAwIDI2NCAxMCBsNjQgMTMgLTI0IC0xOSBjLTEzIC0xMSAtMTkgLTE3IC0xMyAtMTQgMTUgOCAzOAotMjAgMjkgLTM0IC04IC0xMyAzMyA3IDc5IDM5IGwzMCAyMCAyNyAtMjQgYzE2IC0xMyAzNCAtMjUgNDEgLTI4IDE2IC02IC0xOAotMzcgLTExNCAtMTA0IC00MCAtMjcgLTY4IC01NCAtNjggLTY0IDAgLTE0IDU2IC0xODIgMTA1IC0zMTQgNiAtMTcgNCAtMTYKLTEzIDQgbC0xOSAyNCAtNDQgLTI2IGMtMjggLTE2IC03MiAtMzAgLTExOSAtMzcgLTE0MiAtMjAgLTE5MyAtMzEgLTIxNiAtNDgKLTMxIC0yMyAtMzAgLTI2IDEyIC01MSAzNSAtMjEgMzYgLTIzIDI5IC02NyAtMyAtMjQgLTEzIC02MCAtMjAgLTc4IC04IC0xOAotMTIgLTM2IC05IC0zOCA5IC05IC05NyAtMjAgLTMwMSAtMzAgLTI2MCAtMTMgLTMwOSAtMTMgLTQzNSAwIC01OCA2IC0xMTMgMTEKLTEyMiAxMiAtMTYgMCAtMTYgMyAtMyA0MSA4IDIzIDE1IDUwIDE1IDYwIDAgMjYgNyAyNCA2OCAtMTcgNjEgLTQxIDE1MCAtNzQKMTk4IC03NCAxOCAwIDU3IDkgODUgMjAgNzIgMjkgMjM1IDEzNiAyNjAgMTcyIDQ2IDY0IDI5IDE2NSAtMzcgMjE3IC00MiAzMwotNDggMjQgLTEwIC0xNCA0MCAtNDAgNTYgLTk2IDM1IC0xMjEgLTEyIC0xNCAtMjkgLTE2IC0xMDggLTExIC04MyA1IC05NyAzCi0xMjEgLTE0IC0xNSAtMTIgLTUwIC0yMyAtODEgLTI2IC02NiAtNyAtMTExIDEyIC0xMzQgNTcgLTE0IDI3IC0xMyAzOSA2IDE0MgoxMSA2MiAyOSAxMzEgNDAgMTU0IDEwIDIyIDUxIDcxIDkwIDEwOSBsNzEgNjkgMTQgLTI1IGM3IC0xMyAxMyAtNTMgMTQgLTg5CmwwIC02NCA1OCAtNTMgYzMxIC0yOSA2MiAtNTMgNjcgLTUzIDYgMCA5IDM1IDcgOTIgLTMgNzEgMSAxMDggMTYgMTU1IDEyIDM3CjE2IDY2IDExIDc1IC0xNyAyNiAtOSA1NyAyMiA4NSAxNyAxNSA1MCA0NyA3MiA3MSA0MyA0NCA1OSA1NSAzNiAyM3ogbTgyNAotMTM2IGMzMSAtODggNTEgLTIwNCA0MiAtMjQ3IC0xMiAtNTkgLTUzIC0xMTQgLTE0NyAtMjAyIC01MSAtNDcgLTk0IC04NiAtOTcKLTg2IC0xMiAxIC0xNDggMzM4IC0xMzkgMzQ1IDIgMSA0MSAyNyA4OCA1NyA5NiA2MiAxNDYgMTEyIDE3OSAxODIgMjkgNTggMzgKNTIgNzQgLTQ5eiBtMjUgLTQ5MiBjLTIwIC0xNTUgLTUyIC0zNTAgLTcyIC00MzMgLTEyIC01MyAtMTMgLTUxIC0xMCA3MCAxIDY5CjcgMTU0IDEzIDE5MCA1IDM2IDE1IDEwMyAyMiAxNTAgOCA1OCAxOSA5NiAzNyAxMjIgMTMgMjEgMjUgMzggMjYgMzggMSAwIC02Ci02MiAtMTYgLTEzN3ogbS0zMDUgLTI2NiBjLTE1IC03NSAtMjkgLTEzNSAtMzEgLTEzMiAtNiA1IDI3IDIxMCA0MCAyNDYgMjEKNjEgMTggMTggLTkgLTExNHogbS0yMjExIC00MSBjNCAzIDMwIC02NyA1NyAtMTU0IGw1MSAtMTU5IDkxIC0xMTMgOTEgLTExMwotMTYgLTMzIGMtOCAtMTkgLTE5IC0zNCAtMjQgLTM0IC0yMCAwIC0yMjggMjM0IC0yNTYgMjg5IC04IDE0IC0yOCA3OCAtNDYKMTQxIC0xNyA2MyAtMzYgMTI4IC00MSAxNDQgLTEzIDQzIC0xMyA0MyAzOSAzNiAyNiAtNSA1MCAtNiA1NCAtNHogbTU4MCAtNzAKYy0zIC01NyAyIC03OCA1NCAtMjEyIDk5IC0yNTggMTgzIC00NTMgMjgyIC02NTYgOTAgLTE4NCA5NSAtMTk3IDcyIC0xOTEgLTY0CjE0IC03NCAyNiAtMTM5IDE1OCAtNzUgMTUxIC0xMjYgMjcwIC0yMjIgNTIwIC0zOCA5OSAtNzggMTk5IC04OSAyMjMgLTEzIDI3Ci0yMCA2NCAtMjAgMTAzIDAgNTQgMyA2NCAyOSA5MCAxNiAxNiAzMSAyOSAzMyAyOSAyIDAgMiAtMjkgMCAtNjR6IG0xNDA3IC03OApjMTggLTI4IDI3IC0zNSAzNyAtMjcgMjIgMTggLTExIC0xMDEgLTU0IC0xOTMgLTIxIC00NSAtNDkgLTkxIC02MyAtMTAwIC0xMwotMTAgLTU5IC00MCAtMTAyIC02OSAtNDIgLTI4IC04MyAtNjMgLTkxIC03NyAtMjMgLTQ4IC02OSAtMjA2IC02NyAtMjMyIDIKLTE3IC0xNyA0IC02MSA3MCAtODUgMTI4IC04OSAxMzAgLTMwNSAxMzMgLTIxOSAzIC0yMjMgMCAtMzExIC0xNTggLTI0IC00MwotMzIgLTUyIC0yNyAtMzAgOSA0MyA4NiAxNzUgMTA5IDE4NyAxMSA2IDEwOSAxNCAyMjAgMTkgMjc0IDEzIDMwNyAyMyAzODEKMTE3IDQ2IDU4IDU3IDkyIDMwIDkyIC0xMyAwIC0xOSAxMSAtMTcgMzEgMSA0IC0zMCAtOCAtNjcgLTI3IC05MSAtNDUgLTE3NgotNjQgLTI4NyAtNjQgLTE5OCAwIC0zMTkgNTAgLTMwMCAxMjUgNyAyOCAzOCAzNiA5NiAyNSA2MSAtMTIgMTg4IC0xMiAyOTAgMAoxNjggMjEgMjk2IDY5IDQxMCAxNTMgMzAgMjIgNDcgMzEgMzcgMTkgLTExIC0xMSAtMTYgLTI2IC0xMiAtMzEgMyAtNiAxIC0xMQotNSAtMTEgLTYgMCAtOCAtNSAtNCAtMTEgMyAtNiAtMTMgLTMxIC0zNyAtNTUgLTI0IC0yNCAtMzggLTQ0IC0zMyAtNDQgMTIgMAo4MCA3OSAxMDkgMTI1IDUzIDg1IDg1IDkzIDEyNCAzM3ogbTE2NyAtNzkgYy0xNSAtNTYgLTMxIC0xMDkgLTM3IC0xMTggLTkKLTEzIC05IC0xMyAtNCA0IDMgMTEgMTggNjkgMzIgMTMwIDE0IDYwIDI4IDEwNCAzMCA5NyAzIC02IC03IC01OCAtMjEgLTExM3oKbS00MjIgODcgYzggLTMyIC0yMCAtNjQgLTc3IC05MCAtMTMyIC02MCAtMjUxIC04MCAtNDMzIC03NCAtMTI0IDUgLTE0OCA5Ci0yMjMgMzYgLTk3IDM2IC0xMTEgNDYgLTExMSA3NyAwIDUzIDE5IDY4IDUyIDM5IDE2IC0xNiAxOCAtMTYgMjQgMCAxMSAyOQoxMjQgMTggMTI0IC0xMiAwIC0xMyAyIC0xMyAxMyAzIDEyIDE2IDIzIDE3IDgzIDExIDM4IC00IDczIC0xMSA3OCAtMTYgNiAtNgoxNCAtNiAyMSAwIDEzIDExIDE0MyAzMiAxNTUgMjUgNCAtMyAzMSAwIDU5IDcgMzkgOSA1NyA5IDc2IDAgMjEgLTEwIDI5IC05CjQwIDIgOSA4IDM0IDEzIDY0IDEzIDQxIC0xIDUxIC00IDU1IC0yMXogbTQ4NiAtOTcgYy0xMSAtNTIgLTM2IC0xMjcgLTU1Ci0xNjcgLTE5IC00MSAtMzIgLTc5IC0yOSAtODUgNSAtOCAyIC04IC02IDAgLTExIDEwIC03IDI2IDIzIDkwIDIwIDQzIDQ2IDEyMAo1OCAxNzEgMTEgNTEgMjMgOTEgMjUgODkgMyAtMiAtNCAtNDcgLTE2IC05OHogbS0xOTYxIC0yMiBjMTcgLTU0IDU0IC0xNDMgODkKLTIwOSAyIC01IDAgLTggLTUgLTggLTE4IDAgLTczIDEyMCAtOTcgMjE0IC0xNSA1NCAtMjYgMTAzIC0yNSAxMTAgMSAxMiA0IDMKMzggLTEwN3ogbTE2MSAtMzA5IGMyNSAtMzQgOTQgLTEyNyAxNTMgLTIwNyA1OSAtNzkgMTA2IC0xNDYgMTAzIC0xNDggLTIgLTIKLTMwIDMwIC02MiA3MyAtMzMgNDIgLTgxIDEwNCAtMTA4IDEzOCAtMjYgMzMgLTY2IDg3IC04OCAxMTkgLTIxIDMxIC00MiA1NwotNDYgNTcgLTQgMCAtMTUgLTEyIC0yNSAtMjUgLTIzIC0zMiAtMjMgLTMxIDEyMCAtMTg0IDExMCAtMTE3IDE5OSAtMTk1IDIxMgotMTg2IDUgMiAyMiAtMTMgNDAgLTM1IDE4IC0yMiAyOSAtNDAgMjYgLTQwIC0xMSAwIC0xNzUgMTE1IC0yNDYgMTcyIC0zNyAyOQotMTAzIDg3IC0xNDggMTI3IGwtODEgNzUgMTcgMjUgYzEyIDIwIDgzIDEwMSA4OCAxMDEgMCAwIDIxIC0yOCA0NSAtNjJ6Cm0xNzIxIDQgbDM3IC01MiAtMTAyIC0xMDMgYy01NSAtNTYgLTEyMSAtMTE4IC0xNDYgLTEzNyAtNTAgLTM4IC00MyAtMjcgMjgKNDcgMTQ3IDE1MyAxNzUgMTk3IDE1NiAyNDcgLTEwIDI2IC0yMSAxOSAtNTggLTM2IC0xOSAtMjkgLTEwMCAtMTI5IC0xODAKLTIyMyAtMTI5IC0xNTIgLTE2NiAtMjAyIC0xMjEgLTE2NSA4IDcgMTUgMTAgMTUgNyAwIC0yIC0yMSAtMjIgLTQ3IC00MyBsLTQ3Ci0zOCAyMCAzMyBjMTAgMTggNjIgODUgMTE0IDE0OSAxNDEgMTczIDIyNCAyODIgMjUxIDMyOSAxMyAyNCAyOSA0MSAzNCA0MCA2Ci0yIDI2IC0yNyA0NiAtNTV6IG0xMDkgMzUgYzAgLTIgLTEwIC0xMiAtMjIgLTIzIGwtMjMgLTE5IDE5IDIzIGMxOCAyMSAyNiAyNwoyNiAxOXogbS03NDYgLTE4MSBjMTggLTE4IDQ5IC02NSA3MCAtMTA1IGwzNyAtNzEgLTI1IC0xMCBjLTkwIC0zNCAtMTU2IC00NAotMjkxIC00NCAtMTA0IDAgLTE1NyA1IC0yMDUgMTggLTM2IDEwIC03NyAyMSAtOTIgMjMgLTE2IDMgLTI4IDcgLTI4IDkgMCAzCjEyIDI4IDI2IDU3IDM5IDc3IDgzIDEzNyAxMDcgMTQ3IDEyIDUgMTAwIDkgMTk2IDkgbDE3NCAxIDMxIC0zNHoiLz4KPHBhdGggZD0iTTQ2MzAgNTQ1MyBjMCAtOCAtOSAtMTcgLTIwIC0yMCAtMjUgLTcgLTI1IC0xNSAtMSAtMzcgNDIgLTM4IDExNCAyCjc3IDQyIC0yMyAyNiAtNTYgMzUgLTU2IDE1eiIvPgo8cGF0aCBkPSJNNTA4OSA1MjIzIGMtMTggLTIwIC0yOCAtMzMgLTIxIC0yOSAzNyAyMSAtMjEgLTE3NyAtNjcgLTIyOSAtMTcKLTIwIC0zMSAtMzkgLTMwIC00MyAxIC0yMiA0NiAtMTI2IDU0IC0xMjkgNiAtMiA0NiAzMyA5MCA3NyBsNzkgNzkgNCA2MSBjNgo4MiAtMzkgMjUwIC02NiAyNTAgLTUgMCAtMjQgLTE2IC00MyAtMzd6Ii8+CjxwYXRoIGQ9Ik0zODM4IDM3ODQgYy0zMSAtMTYgLTY4IC04MCAtNjggLTExNyAwIC0zNSAyMyAtNjEgNDcgLTUzIDE2IDUgMjIKMTggMjcgNjIgMyAzMSAxMyA3MSAyMSA5MCAxNiAzOCAxMiA0MCAtMjcgMTh6Ii8+CjxwYXRoIGQ9Ik00MTIzIDcyNDMgYzkgLTIgMjMgLTIgMzAgMCA2IDMgLTEgNSAtMTggNSAtMTYgMCAtMjIgLTIgLTEyIC01eiIvPgo8cGF0aCBkPSJNNDE3OCA3MjMzIGM2IC0yIDE4IC0yIDI1IDAgNiAzIDEgNSAtMTMgNSAtMTQgMCAtMTkgLTIgLTEyIC01eiIvPgo8cGF0aCBkPSJNNDY4MCA3MDU2IGMwIC0zIDkgLTEwIDIwIC0xNiAxMSAtNiAyMCAtOCAyMCAtNiAwIDMgLTkgMTAgLTIwIDE2Ci0xMSA2IC0yMCA4IC0yMCA2eiIvPgo8cGF0aCBkPSJNNTAwMCA2ODI2IGMwIC00IDIzIC0zMyA1MSAtNjQgNjEgLTY3IDEyMiAtMTU1IDE2NyAtMjQyIDE4IC0zNiAzMAotNTQgMjYgLTQwIC0xMCA0MCAtNjEgMTMwIC0xMDcgMTkxIC01NyA3NiAtMTM2IDE2NiAtMTM3IDE1NXoiLz4KPHBhdGggZD0iTTUyODEgNjM1NCBjMCAtMTEgMyAtMTQgNiAtNiAzIDcgMiAxNiAtMSAxOSAtMyA0IC02IC0yIC01IC0xM3oiLz4KPHBhdGggZD0iTTIxNjIgNTgwNCBjMTMgLTExMiAxMTMgLTM1OCAxNjggLTQxMiAxNiAtMTYgNDkgLTM0IDc3IC00MiAyNiAtNgo1NiAtMTQgNjYgLTE3IDI1IC02IDIxIC0yMyAtNiAtMjMgLTEzIDAgLTQ2IC03IC03MyAtMTUgLTQ4IC0xNCAtNTEgLTE3IC02NwotNjkgLTEwIC0yOSAtMTQgLTYyIC0xMCAtNzEgNCAtMTEgMiAtMTYgLTQgLTEyIC01IDMgLTkgLTcgLTkgLTI2IDAgLTE4IC0xMAotNzggLTIyIC0xMzQgLTEyIC01NyAtMjQgLTEyOSAtMjUgLTE2MSAtMiAtMzIgLTcgLTYzIC0xMCAtNzAgLTQgLTYgMjcgNSA3MAoyNSAxMjMgNTcgMzM5IDEzNiA1ODggMjE3IDM4MSAxMjIgNDUxIDE0NiA0MjIgMTQwIC0xNiAtMiAtMjYgLTEgLTIzIDQgMyA1Ci00IDE4IC0xNSAyOCAtMTIgMTAgLTI4IDMyIC0zNyA0OSAtMjMgNDQgLTgyIDIzNCAtODIgMjY0IDAgNDcgLTEyIDY5IC00MSA4MQotMzUgMTUgLTM4IDMwIC02IDMxIDMyIDEgLTIyIDE3IC00MDMgMTE5IC0xODQgNTAgLTM4NSAxMDYgLTQ0NiAxMjUgLTYyIDE5Ci0xMTQgMzUgLTExNiAzNSAtMiAwIC0xIC0zMCA0IC02NnoiLz4KPHBhdGggZD0iTTYyMzAgNTc1MyBsLTk2IC00IC0yMyAtMTgyIGMtMTIgLTEwMCAtNDQgLTM1MSAtNzAgLTU1NyBsLTQ4IC0zNzUKOTEgLTggYzUwIC01IDE4OCAtNiAzMDYgLTQgMzIxIDcgNDMwIDM1IDUyMCAxMzQgNTkgNjQgODAgMTI1IDgwIDIyNyAwIDExNAotNjAgMjAyIC0xNTMgMjIyIC01MiAxMSAtNTEgMTUgMTIgNDQgODEgMzkgMTM2IDk1IDE1NSAxNjEgMjQgODEgMjEgMTQ2IC0xMQoyMTAgLTI1IDQ3IC0zNiA1OCAtOTMgODYgLTk4IDQ5IC0yNTIgNjAgLTY3MCA0NnogbTUyNSAtMjMgYzc0IC0xMSAxNTIgLTQzCjE5OSAtODMgMjUgLTIwIDMwIC0zMiAzNCAtODUgbDQgLTYwIC0xMDMgNSAtMTAyIDYgLTQxIDQyIGMtMzIgMzMgLTUzIDQ1IC05NAo1NCAtNTkgMTIgLTE1NSAxNCAtMjI1IDUgLTQyIC02IC00NyAtMTAgLTUyIC0zOCAtNiAtMzAgLTggLTMxIC00OCAtMjkgLTIzIDIKLTcyIDggLTEwOSAxNCBsLTY4IDExIDAgNDggYzAgMjYgMyA2MSA2IDc4IDYgMjkgMTAgMzEgNTMgMzUgMTA1IDggNDgxIDYgNTQ2Ci0zeiBtLTgyIC0xNTQgYzU1IC0yMyA3MiAtNTEgNzIgLTExNiAwIC02NyAtMjAgLTEwMiAtNzYgLTEzNSAtMjggLTE2IC01NwotMjAgLTE2NiAtMjMgLTczIC0zIC0xMzMgMCAtMTMzIDQgMCA1IDcgNjUgMTUgMTM0IDggNjkgMTUgMTMxIDE1IDEzOCAwIDE4CjIyOSAxNyAyNzMgLTJ6IG0tMjUgLTQ3MCBjNjUgLTM0IDc3IC0xMjcgMzAgLTIxOSAtMzEgLTYyIC04NSAtODEgLTI0MSAtODUKbC0xMjggLTQgNSAyMyBjMyAxMyAxMCA2OSAxNiAxMjQgMTcgMTU3IDIwIDE3MyAzOCAxNzkgOSAyIDY5IDQgMTMyIDIgODggLTEKMTIzIC02IDE0OCAtMjB6Ii8+CjxwYXRoIGQ9Ik04NTg2IDU3MDggYy0zIC0yNCAtMTMgLTk5IC0yMiAtMTY4IGwtMTYgLTEyNSAtMTMyIDAgYy0yMDUgMCAtMzE5Ci00MyAtMzg3IC0xNDUgLTU0IC04MSAtODQgLTIyNSAtNzcgLTM4MCAzIC04MiA3IC0xMDIgMzEgLTE0MiA2OCAtMTE2IDE4MwotMTQyIDUzNiAtMTE4IDEwMiA2IDE4OSAxNSAxOTMgMTggNCA0IDIxIDEyNiAzOCAyNzIgMTcgMTQ2IDQ0IDM3MSA1OSA1MDAgMTYKMTI5IDMxIDI1NiAzNCAyODMgbDUgNDcgLTEyOCAwIC0xMjggMCAtNiAtNDJ6IG0yNDQgMTkgYzAgLTcgLTExIC04MSAtMjUKLTE2NSAtMTQgLTg0IC0yNSAtMTU0IC0yNSAtMTU1IDAgLTcgLTkwIC04IC0xNDMgLTIgbC01OSA3IDYgOTIgYzMgNTAgOCAxMjQKMTIgMTY0IGw2IDcyIDExNCAwIGM4NiAwIDExNCAtMyAxMTQgLTEzeiBtLTMzMiAtNDgzIGMyNyAtOCAyNyAtNiAtMTIgLTI4OQpsLTIxIC0xNjAgLTkzIC0zIGMtOTEgLTMgLTkzIC0yIC0xMjIgMjcgLTI4IDI4IC0zMCAzNCAtMzAgMTEzIDAgOTUgMjEgMjA0CjQ3IDI0OSAxMCAxOCAzNiA0MCA1OCA1MCA0MCAxOSAxMjcgMjUgMTczIDEzeiIvPgo8cGF0aCBkPSJNOTUyMSA1NjU4IGMtNiAtNTEgLTE2IC0xMjcgLTIyIC0xNjkgbC0xMSAtNzYgLTEyNiAxIGMtMjU1IDIgLTM2NwotNjIgLTQzMiAtMjQ2IC0xNyAtNDkgLTIzIC05MyAtMjcgLTIwMyAtNSAtMTMwIC00IC0xNDUgMTcgLTE5MyAyOCAtNjQgNzIKLTEwNCAxNDIgLTEyOCA0MyAtMTUgODMgLTE5IDIwOCAtMTkgODUgMCAyMDggNCAyNzMgOCAxMDkgOCAxMTcgMTEgMTIxIDMwIDMKMTIgMTIgODcgMjEgMTY3IDkgODAgMjUgMjE1IDM2IDMwMCAyNCAxOTcgNjkgNTkxIDY5IDYwNyAwIDEwIC0zMSAxMyAtMTI5IDEzCmwtMTI4IDAgLTEyIC05MnogbTI1OSA3MCBjMCAtMTQgLTE0IC05NiAtNDIgLTIzOCBsLTIwIC0xMDUgLTk2IDMgYy01MyAyIC05OAo1IC0xMDAgNyAtNSA0IDE2IDI4OSAyNCAzMjMgNCAyMSA4IDIyIDExOSAyMiA4MiAwIDExNSAtMyAxMTUgLTEyeiBtLTMxNwotNDg4IGM1IC00IC00MSAtNDA3IC00OSAtNDM3IC0yIC05IC0zMCAtMTMgLTkzIC0xMyAtODEgMCAtOTIgMiAtMTIwIDI1IC0zOAozMyAtNDYgODEgLTMyIDE5NSAxOSAxNDkgNDkgMjA5IDExNyAyMzAgMjkgOSAxNjggOSAxNzcgMHoiLz4KPHBhdGggZD0iTTExMzE3IDU3MjkgYy0yMyAtMjEgLTI3IC0zNCAtMzMgLTExMCBsLTYgLTg2IDEwOSAtNiBjMTU1IC05IDE0OAotMTMgMTYzIDk5IDkgNjUgOSA5OSAyIDEwNiAtNSA1IC01NCAxMiAtMTA5IDE1IC05NCA1IC0xMDAgNCAtMTI2IC0xOHogbTIyNwotMjkgYy00IC02NiAtMTggLTEzMyAtMzEgLTE0NiAtMTEgLTEwIC00MSAtMTQgLTExNCAtMTQgbC0xMDAgMCA3IDczIGMxMiAxMjMKNiAxMTggMTMxIDExNSBsMTA4IC0zIC0xIC0yNXoiLz4KPHBhdGggZD0iTTEwODY2IDU3MDggYy0zIC0xMyAtMTYgLTExMyAtMzEgLTIyMyAtMTQgLTExMCAtMzYgLTI3NCAtNDkgLTM2NQotMzQgLTIzMiAtNjYgLTQ2MyAtNjYgLTQ3NyAwIC0xMCAzNCAtMTMgMTM0IC0xMyA3NCAwIDEzNyA0IDE0MCA4IDMgNSAyMyAxNTQKNDUgMzMzIDIzIDE3OCA1MiA0MTEgNjYgNTE4IDE0IDEwNiAyNSAyMDQgMjUgMjE3IGwwIDI0IC0xMzAgMCBjLTEyNiAwIC0xMzAKLTEgLTEzNCAtMjJ6IG0yNTQgLTEzIGMwIC0xNCAtNiAtNTQgLTE0IC04OCAtOCAtMzQgLTIyIC0xMDIgLTMxIC0xNTIgLTkgLTQ5Ci0xOSAtOTIgLTIxIC05NSAtMyAtMyAtNDIgLTggLTg3IC0xMSAtNDUgLTMgLTkwIC05IC05OSAtMTMgLTE2IC03IC0xOCAtMgotMTggNTEgMCAzMyA0IDk1IDEwIDEzOSA1IDQzIDEyIDEwNSAxNSAxMzcgbDYgNTcgMTIwIDAgMTE5IDAgMCAtMjV6Ii8+CjxwYXRoIGQ9Ik0xMTc0NSA1NzA4IGMtMiAtMTMgLTExIC03NSAtMjAgLTEzOCAtOCAtNjMgLTIwIC0xNDYgLTI1IC0xODUgLTIwCi0xNDEgLTkwIC03MDggLTkwIC03MzEgMCAtMjQgMCAtMjQgMTI5IC0yNCA3MyAwIDEzMiA0IDEzNiAxMCAzIDUgMTMgODQgMjIKMTc1IDEwIDkxIDIwIDE2NSAyMyAxNjUgMyAwIDEyIC0xMiAyMSAtMjggNzUgLTEyOCAxNjcgLTI3MiAxODcgLTI5NCAyNiAtMjgKMjYgLTI4IDE2NSAtMjggNzYgMCAxMzcgNCAxMzUgOCAtNyAxNyAtMTUwIDI0MiAtMjExIDMzMiBsLTY0IDk1IDE0NiAxNDkgYzgwCjgyIDEzMCAxMzggMTExIDEyMyAtMTkgLTE1IC00OSAtMzUgLTY2IC00MyAtMjkgLTE1IC0zMyAtMTUgLTgzIDExIC0zOCAxOQotNTEgMzEgLTQ3IDQxIDMgOSA2IDE4IDYgMjAgMCAyIDI4IDQgNjMgNSAzNCAxIDg5IDUgMTIyIDkgNTEgNiA0MSA3IC02NiA5CmwtMTI2IDEgLTEzNCAtMTI5IGMtNzMgLTcyIC0xMzUgLTEyOCAtMTM3IC0xMjcgLTEgMiA5IDEwOCAyMyAyMzYgMTUgMTI3IDI1CjIzMyAyMyAyMzYgLTIgMiAtMTUgLTU1IC0yOCAtMTI3IC0xMyAtNzIgLTI4IC0xMzMgLTMzIC0xMzYgLTUgLTMgLTUyIC03Ci0xMDQgLTkgbC05NiAtMyA3IDEzNyBjMTAgMTc1IDE5IDI0MiAzNyAyNTMgMTEgNyAxMSA5IC0zIDkgLTEwIDAgLTIwIC0xMAotMjMgLTIyeiIvPgo8cGF0aCBkPSJNMTE4MjAgNTcyNCBjODMgLTggMTkwIC04IDE5MCAtMSAwIDQgLTUxIDYgLTExMiA1IC02MiAtMSAtOTcgLTMKLTc4IC00eiIvPgo8cGF0aCBkPSJNMzI3OCA1NjkzIGM3IC0zIDE2IC0yIDE5IDEgNCAzIC0yIDYgLTEzIDUgLTExIDAgLTE0IC0zIC02IC02eiIvPgo8cGF0aCBkPSJNMTI4MDUgNTQwMCBjLTgzIC0xMSAtMTcyIC00NCAtMjE1IC03OCAtODAgLTY1IC0xMjIgLTE5OSAtMTI0IC0zOTcKLTEgLTEwNyAyIC0xMjUgMjIgLTE2NyAyOSAtNTggNTYgLTgxIDEyOSAtMTA4IDg3IC0zMiAxOTcgLTQ0IDMxNiAtMzIgMjI4IDIzCjMxNSA5NiAzNjIgMzAyIDU5IDI2NSA5IDQxOCAtMTUyIDQ2MyAtNzEgMjAgLTI1MyAyOSAtMzM4IDE3eiBtMjgzIC0yOSBjMjMKLTcgNDIgLTE2IDQyIC0yMiAwIC02IC00IC04IC05IC00IC01IDMgLTEyIDEgLTE1IC0zIC0zIC01IC0yNiAtMTAgLTUzIC0xMQotMjYgLTEgLTU4IC04IC03MCAtMTcgLTI5IC0xOCAtMTIzIC0zMSAtMTIzIC0xNiAwIDggLTc1IDE3IC0xODIgMjIgLTI5IDIKLTIxIDE2IDIwIDM0IDczIDMzIDI5NSA0MyAzOTAgMTd6IG0tNzEgLTE1NSBjMjcgLTIzIDI4IC0yOCAyNyAtMTA4IDAgLTk4Ci0yMCAtMjA5IC00NSAtMjU5IC0zMCAtNjEgLTEzNSAtODggLTIxMyAtNTUgLTQzIDE4IC01MCA0MCAtNDggMTQ2IDYgMjMzIDQ3CjMwMCAxODQgMzAwIDU2IDAgNzEgLTQgOTUgLTI0eiIvPgo8cGF0aCBkPSJNNzE0NiA1MzY2IGMtMTcgLTkwIC00NyAtMzEyIC01NyAtNDIwIC0xMCAtMTA3IC05IC0xMzAgNSAtMTc4IDgKLTMwIDI4IC02OCA0MyAtODMgNjkgLTcwIDE5NSAtOTEgMzMyIC01NiA2MiAxNSA4OCAxOCA5NyAxMCA5IC03IDU1IC0xMCAxMzEKLTcgbDExOCA0IDggNzQgYzUgNDEgMjIgMTc2IDM4IDMwMCAxNiAxMjQgMzIgMjU5IDM1IDMwMSBsNyA3NiAtMTI0IDUgYy02OCAzCi0xMjYgNCAtMTI4IDIgLTIgLTIgLTE4IC0xMjAgLTM2IC0yNjQgLTIyIC0xNzQgLTM5IC0yNjkgLTQ5IC0yODYgLTI3IC00MAotNjQgLTU4IC0xMjEgLTU4IC01OSAtMSAtOTAgMTggLTk4IDYxIC0yIDE0IDYgMTE2IDE5IDIyNyAxNCAxMTAgMjcgMjI4IDMwCjI2MSBsNiA2MCAtMTI1IDEgLTEyNSAxIC02IC0zMXoiLz4KPHBhdGggZD0iTTk4NTEgNTMzMyBjMTEgLTMyIDQ5IC0xNTkgODUgLTI4MyA4MSAtMjgyIDEyMCAtMzkxIDE0NCAtNDEwIDIwCi0xNSAyMCAtMTYgLTEgLTU3IC0zMiAtNjQgLTg3IC04OCAtMTkwIC03OSAtNDMgNCAtNzkgNSAtNzkgNCAwIC0yIC03IC00MQotMTQgLTg4IC04IC00NyAtMTEgLTg5IC02IC05NCA0IC00IDY4IC02IDE0MiAtNSAxMjcgNCAxMzcgNiAyMDAgMzcgMTEzIDU1CjE0MSA5OCAzMjggNDkwIDY1IDEzNiAxNDkgMzEzIDE4OCAzOTUgbDcxIDE0NyAtMTI0IDAgLTEyNSAwIC00MyAtOTIgYy0yMwotNTEgLTc0IC0xNjYgLTExMiAtMjU1IC0zOSAtOTAgLTcyIC0xNjMgLTc2IC0xNjMgLTMgMCAtMjkgMTAwIC01OSAyMjMgLTI5CjEyMiAtNTcgMjM3IC02MiAyNTUgbC05IDMyIC0xMzkgMCAtMTM5IDAgMjAgLTU3eiBtMjM5IDE3IGMwIC0yNyAtNDYgLTQ1IC04MQotMzMgLTI4IDExIC03NSAxMCAtMTAwIC0xIC0xMyAtNSAtMTkgMCAtMjcgMjMgbC0xMSAzMSAxMTAgMCBjMTAzIDAgMTA5IC0xCjEwOSAtMjB6IG01OTAgMTMgYy0xIC0yNiAtMjMgLTM0IC05OSAtMzggLTQ1IC0zIC04NiAtNyAtOTIgLTEwIC01IC00IC05IDgKLTkgMjQgbDAgMzEgMTAwIDAgYzU1IDAgMTAwIC0zIDEwMCAtN3oiLz4KPHBhdGggZD0iTTExMjYwIDUzODggYzAgLTIgLTExIC04NCAtMjUgLTE4MyAtMTQgLTk5IC0zNCAtMjUyIC00NSAtMzQwIC0xMQotODggLTIyIC0xNzcgLTI1IC0xOTcgbC01IC0zOCAxMzQgMCAxMzUgMCA2IDQzIGMyOCAyMDIgNzcgNTg2IDgyIDY0NSBsNiA3MgotMTMyIDAgYy03MiAwIC0xMzEgLTEgLTEzMSAtMnoiLz4KPC9nPgo8L3N2Zz4K',
                            alt: 'Buddyliko',
                            style: {
                                width: '100%',
                                maxWidth: '100%',
                                height: 'auto',
                                display: 'block',
                                margin: '0 auto 0 auto',
                                borderRadius: '8px'
                            }
                        }),
                        React.createElement('p', {
                            style: {
                                fontSize: '36px',
                                margin: '-8px 0 0 0',
                                opacity: 1,
                                fontStyle: 'italic',
                                fontWeight: '700',
                                letterSpacing: '0.4px',
                                textAlign: 'center',
                                textShadow: '0 1px 3px rgba(0,0,0,0.3)'
                            }
                        }, 'Your Buddy in transformations')
                    )
                ),
                React.createElement('div', { className: 'sidebar-content' },
                    statusMessage && React.createElement('div', { 
                        className: `status-message status-${statusMessage.type}` 
                    }, statusMessage.message),
                    React.createElement('div', { className: 'tabs' },
                        React.createElement('div', { 
                            className: `tab ${activeTab === 'input' ? 'active' : ''}`,
                            onClick: () => setActiveTab('input')
                        }, 'üì• Input'),
                        React.createElement('div', { 
                            className: `tab ${activeTab === 'output' ? 'active' : ''}`,
                            onClick: () => setActiveTab('output')
                        }, 'üì§ Output'),
                        React.createElement('div', { 
                            className: `tab ${activeTab === 'connections' ? 'active' : ''}`,
                            onClick: () => setActiveTab('connections')
                        }, `üîó ${connections.length}`),
                        React.createElement('div', { 
                            className: `tab ${activeTab === 'schemas' ? 'active' : ''}`,
                            onClick: () => setActiveTab('schemas')
                        }, 'üìã Schemas')
                    ),
                    activeTab === 'input' && React.createElement('div', null,
                        React.createElement('div', { style: { marginBottom: '10px' } },
                            React.createElement('label', { style: { display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '13px' } }, 'üìã Select Schema Type:'),
                            React.createElement('select', {
                                id: 'inputSchemaTypeSelect',
                                className: 'schema-type-select',
                                style: { width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ddd', fontSize: '13px' },
                                value: inputSchemaId,
                                onChange: (e) => setInputSchemaId(e.target.value)
                            },
                                React.createElement('option', { value: '' }, '-- Select schema type --'),
                                availableInputSchemas.map(schema => 
                                    React.createElement('option', { 
                                        key: schema.name, 
                                        value: schema.name 
                                    }, `${schema.name}${schema.hasXsd ? ' ‚úÖ' : ''}${schema.hasSchematron ? ' üìã' : ''}`)
                                )
                            )
                        ),
                        React.createElement('button', {
                            className: 'btn btn-primary btn-full',
                            onClick: () => {
                                setUploadDirection('input');
                                setShowUploadModal(true);
                            }
                        }, 'üì§ Upload Input Schema'),
                        React.createElement('label', {
                            className: 'btn btn-secondary btn-full',
                            style: { cursor: 'pointer' }
                        }, 
                            inputExample ? '‚úÖ Example File Loaded' : 'üìÑ Upload Example File',
                            React.createElement('input', {
                                type: 'file',
                                accept: '.xml,.json,.txt,.csv',
                                style: { display: 'none' },
                                onChange: (e) => e.target.files[0] && uploadExampleFile(e.target.files[0], 'input')
                            })
                        ),
                        React.createElement('button', {
                            className: 'btn btn-secondary btn-full',
                            onClick: () => inputSchema ? exportFieldsCSV('input') : downloadSampleCSV('input')
                        }, inputSchema ? 'üì• Export Fields CSV' : 'üì• Download Sample CSV'),
                        inputSchema ? React.createElement('div', { style: { fontSize: '12px', color: '#666', marginBottom: '10px' } },
                            `${inputSchema.field_count} fields - Drag to canvas`
                        ) : React.createElement('div', { className: 'empty-state' },
                            React.createElement('div', { style: { fontSize: '48px' } }, 'üìã'),
                            React.createElement('p', null, 'Upload CSV schema')
                        )
                    ),
                    activeTab === 'output' && React.createElement('div', null,
                        React.createElement('div', { style: { marginBottom: '10px' } },
                            React.createElement('label', { style: { display: 'block', marginBottom: '5px', fontWeight: 'bold', fontSize: '13px' } }, 'üìã Select Schema Type:'),
                            React.createElement('select', {
                                id: 'outputSchemaTypeSelect',
                                className: 'schema-type-select',
                                style: { width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ddd', fontSize: '13px' },
                                value: outputSchemaId,
                                onChange: (e) => setOutputSchemaId(e.target.value)
                            },
                                React.createElement('option', { value: '' }, '-- Select schema type --'),
                                availableOutputSchemas.map(schema => 
                                    React.createElement('option', { 
                                        key: schema.name, 
                                        value: schema.name 
                                    }, `${schema.name}${schema.hasXsd ? ' ‚úÖ' : ''}${schema.hasSchematron ? ' üìã' : ''}`)
                                )
                            )
                        ),
                        React.createElement('button', {
                            className: 'btn btn-primary btn-full',
                            onClick: () => {
                                setUploadDirection('output');
                                setShowUploadModal(true);
                            }
                        }, 'üì§ Upload Output Schema'),
                        React.createElement('label', {
                            className: 'btn btn-secondary btn-full',
                            style: { cursor: 'pointer' }
                        }, 
                            outputExample ? '‚úÖ Example File Loaded' : 'üìÑ Upload Example File',
                            React.createElement('input', {
                                type: 'file',
                                accept: '.xml,.json,.txt,.csv',
                                style: { display: 'none' },
                                onChange: (e) => e.target.files[0] && uploadExampleFile(e.target.files[0], 'output')
                            })
                        ),
                        React.createElement('button', {
                            className: 'btn btn-secondary btn-full',
                            onClick: () => outputSchema ? exportFieldsCSV('output') : downloadSampleCSV('output')
                        }, outputSchema ? 'üì§ Export Fields CSV' : 'üì• Download Sample CSV'),
                        outputSchema ? React.createElement('div', { style: { fontSize: '12px', color: '#666', marginBottom: '10px' } },
                            `${outputSchema.field_count} fields - Drag to canvas`
                        ) : React.createElement('div', { className: 'empty-state' },
                            React.createElement('div', { style: { fontSize: '48px' } }, 'üìã'),
                            React.createElement('p', null, 'Upload CSV schema')
                        )
                    ),
                    activeTab === 'connections' && React.createElement('div', {
                        style: {
                            overflowY: 'auto',
                            maxHeight: 'calc(100vh - 280px)',
                            paddingRight: '4px'
                        }
                    },
                        React.createElement(ConnectionsList, {
                            connections,
                            selectedConnection,
                            setSelectedConnection
                        })
                    ),
                    activeTab === 'schemas' && React.createElement('div', { style: { padding: '10px' } },
                        React.createElement('h3', { style: { marginBottom: '15px', fontSize: '16px' } }, 'üìã Schema Management'),
                        React.createElement('p', { style: { fontSize: '13px', color: '#666', marginBottom: '15px' } }, 
                            'Upload a ZIP file containing schema.xsd and rules.sch. The schema will be added to both input/ and output/ directories.'
                        ),
                        React.createElement('label', {
                            className: 'btn btn-primary btn-full',
                            style: { cursor: 'pointer', marginBottom: '10px' }
                        }, 
                            'üì¶ Upload Schema ZIP',
                            React.createElement('input', {
                                type: 'file',
                                accept: '.zip',
                                style: { display: 'none' },
                                onChange: async (e) => {
                                    const file = e.target.files[0];
                                    if (!file) return;
                                    
                                    showStatus('‚è≥ Uploading schema...', 'info');
                                    
                                    const formData = new FormData();
                                    formData.append('file', file);
                                    
                                    try {
                                        const res = await fetch(`${API_URL}/schemas/upload`, {
                                            method: 'POST',
                                            body: formData
                                        });
                                        
                                        if (!res.ok) {
                                            const error = await res.json();
                                            throw new Error(error.detail || 'Upload failed');
                                        }
                                        
                                        const data = await res.json();
                                        showStatus(`‚úÖ Schema "${data.schemaName}" uploaded successfully!`, 'success');
                                        
                                        // Reload schemas list
                                        loadAvailableSchemas();
                                        
                                        // Reset file input
                                        e.target.value = '';
                                    } catch (err) {
                                        console.error('Upload error:', err);
                                        showStatus(`‚ùå Upload failed: ${err.message}`, 'error');
                                    }
                                }
                            })
                        ),
                        React.createElement('div', { style: { marginTop: '20px', padding: '10px', background: '#f0f0f0', borderRadius: '6px', fontSize: '12px' } },
                            React.createElement('strong', null, 'ZIP Structure:'),
                            React.createElement('pre', { style: { margin: '5px 0', fontFamily: 'monospace', fontSize: '11px' } },
                                `schema_name/\n  ‚îú‚îÄ‚îÄ schema.xsd (required)\n  ‚îî‚îÄ‚îÄ rules.sch (optional)`
                            )
                        ),
                        React.createElement('button', {
                            className: 'btn btn-secondary btn-full',
                            style: { marginTop: '10px' },
                            onClick: loadAvailableSchemas
                        }, 'üîÑ Refresh Schema List')
                    )
                ),
                React.createElement('div', { className: 'sidebar-footer' },
                    React.createElement('div', { className: 'user-info' },
                        React.createElement('div', { className: 'user-avatar' },
                            (localStorage.getItem('datamapper_user') ? 
                                JSON.parse(localStorage.getItem('datamapper_user')).name?.charAt(0).toUpperCase() : 
                                'U')
                        ),
                        React.createElement('div', { className: 'user-details' },
                            React.createElement('div', { className: 'user-name' },
                                (localStorage.getItem('datamapper_user') ? 
                                    JSON.parse(localStorage.getItem('datamapper_user')).name || 'User' : 
                                    'Anonymous')
                            ),
                            React.createElement('div', { className: 'user-email' },
                                (localStorage.getItem('datamapper_user') ? 
                                    JSON.parse(localStorage.getItem('datamapper_user')).email || '' : 
                                    'Not logged in')
                            )
                        )
                    ),
                    localStorage.getItem('datamapper_token') && React.createElement('button', {
                        className: 'btn-logout',
                        onClick: () => {
                            if (confirm('Are you sure you want to logout?')) {
                                logout();
                            }
                        }
                    }, 'üö™ Logout')
                )
            );
        }
        
        function MainCanvas({ inputSchema, outputSchema, connections, draggedField, setDraggedField, addConnection, mappingName, setMappingName, saveMapping, canvasRef, fieldPositions, updateFieldPositions, selectedConnection, setSelectedConnection, saveSessionToBackend, clearSession, sessionLoaded, inputExample, outputExample, hoverPopup, setHoverPopup, hoverTimeoutRef, setShowFormulaEditor, setEditingConnection, runAIAutoMap, runBusinessRulesAutomap, aiProcessing, setShowSettings, searchQuery, setSearchQuery, performSearch, nextSearchResult, searchResults, currentSearchIndex, saveProject, loadProject, reverseMapping, setPopupPinned, popupPinned, setShowSchemaEditor, hideConnected, setHideConnected, onOpenNodeImport, onFieldContextMenu, onEditNode, onDeleteNode, exportDiagram }) {
            const [dropTarget, setDropTarget] = useState(null);
            
            const handleDrop = (targetField, targetType) => {
                if (!draggedField) return;
                
                if (draggedField.type === 'input' && targetType === 'output') {
                    addConnection(draggedField.field, targetField);
                } else if (draggedField.type === 'output' && targetType === 'input') {
                    addConnection(targetField, draggedField.field);
                } else {
                    // Same side drop - not allowed
                }
                
                setDraggedField(null);
                setDropTarget(null);
            };
            
            return React.createElement('div', { className: 'main-canvas' },
                React.createElement('div', { className: 'toolbar' },
                    React.createElement('div', {
                        style: { display: 'flex', alignItems: 'center', gap: '8px', marginRight: '20px' }
                    },
                        React.createElement('input', {
                            type: 'text',
                            className: 'search-input',
                            placeholder: 'Search fields (RegExp supported)...',
                            value: searchQuery,
                            onChange: (e) => setSearchQuery(e.target.value),
                            onKeyPress: (e) => { if (e.key === 'Enter') performSearch(); }
                        }),
                        React.createElement('button', {
                            className: 'btn btn-primary',
                            onClick: performSearch,
                            disabled: !searchQuery.trim(),
                            title: 'Search for fields matching pattern'
                        }, 'üîç Search'),
                        React.createElement('button', {
                            className: 'btn btn-secondary',
                            onClick: nextSearchResult,
                            disabled: searchResults.length === 0,
                            title: `Next result (${currentSearchIndex + 1}/${searchResults.length})`
                        }, `üîΩ Next ${searchResults.length > 0 ? `(${currentSearchIndex + 1}/${searchResults.length})` : ''}`)
                    ),
                    React.createElement('input', {
                        type: 'text',
                        placeholder: 'Mapping name...',
                        value: mappingName,
                        onChange: (e) => setMappingName(e.target.value),
                        style: { width: '200px' }
                    }),
                    React.createElement('button', {
                        className: 'btn btn-success',
                        onClick: saveMapping
                    }, 'üíæ Save Mapping'),
                    React.createElement('button', {
                        className: 'btn btn-secondary',
                        onClick: () => window.exportMappingCSV?.(),
                        disabled: connections.length === 0,
                        title: 'Export mapping as CSV'
                    }, 'üìä Export CSV'),
                    React.createElement('button', {
                        className: 'btn btn-secondary',
                        onClick: () => window.exportMappingJSON?.(),
                        disabled: connections.length === 0,
                        title: 'Export mapping as JSON'
                    }, 'üìÑ Export JSON'),
                    React.createElement('button', {
                        className: 'btn btn-secondary',
                        onClick: exportDiagram,
                        disabled: connections.length === 0,
                        title: 'Esporta diagramma SVG della mappatura',
                        style: { background: connections.length > 0 ? 'linear-gradient(135deg, #667eea, #764ba2)' : undefined, color: connections.length > 0 ? '#fff' : undefined, border: 'none' }
                    }, 'üó∫Ô∏è Diagramma'),
                    React.createElement('div', {
                        style: { 
                            width: '2px', 
                            height: '30px', 
                            background: '#ddd', 
                            margin: '0 10px' 
                        }
                    }),
                    React.createElement('button', {
                        className: 'btn btn-success',
                        onClick: saveProject,
                        disabled: !mappingName || !inputSchema || !outputSchema,
                        title: 'Save complete project (schemas + examples + mappings)'
                    }, 'üì¶ Save Project'),
                    React.createElement('button', {
                        className: 'btn btn-primary',
                        onClick: loadProject,
                        title: 'Load project from file'
                    }, 'üìÇ Load Project'),
                    React.createElement('button', {
                        className: 'btn btn-danger',
                        onClick: reverseMapping,
                        disabled: !inputSchema || !outputSchema || connections.length === 0,
                        title: 'Reverse mapping: Swap input‚Üîoutput and invert transformations'
                    }, 'üîÑ Reverse'),
                    React.createElement('button', {
                        className: `btn ${hideConnected ? 'btn-success' : 'btn-secondary'}`,
                        onClick: () => setHideConnected(!hideConnected),
                        disabled: connections.length === 0,
                        title: hideConnected ? 'Show all fields' : 'Hide connected fields'
                    }, hideConnected ? 'üëÅÔ∏è Show All' : 'üôà Hide Connected'),
                    React.createElement('button', {
                        className: 'btn btn-success',
                        onClick: () => {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = '.xml,.json,.csv';
                            input.onchange = async (e) => {
                                const file = e.target.files[0];
                                if (!file) return;
                                
                                try {
                                    // Prepare mapping rules
                                    const mappingRules = {
                                        connections: connections.map(conn => ({
                                            source: conn.source,
                                            target: conn.target,
                                            sourceName: conn.sourceName,
                                            targetName: conn.targetName,
                                            transformation: conn.transformation
                                        })),
                                        inputSchema: inputSchema,
                                        outputSchema: outputSchema
                                    };
                                    
                                    console.log('üì§ Sending transform with', connections.length, 'connections');
                                    console.log('Mapping rules:', mappingRules);
                                    
                                    const formData = new FormData();
                                    formData.append('file', file);
                                    formData.append('output_format', 'xml');
                                    formData.append('validate', 'false');
                                    formData.append('mapping_rules', JSON.stringify(mappingRules));
                                    
                                    const res = await fetch(`${API_URL}/transform/execute`, {
                                        method: 'POST',
                                        body: formData
                                    });
                                    
                                    if (res.ok) {
                                        const blob = await res.blob();
                                        const url = window.URL.createObjectURL(blob);
                                        const a = document.createElement('a');
                                        a.href = url;
                                        a.download = 'transformed_output.xml';
                                        a.click();
                                        window.URL.revokeObjectURL(url);
                                        console.log('‚úÖ Transformation complete! File downloaded.');
                                    } else {
                                        const error = await res.json();
                                        console.error('‚ùå Transformation failed:', error);
                                        alert(`Transformation failed: ${error.errors ? error.errors.join(', ') : 'Unknown error'}`);
                                    }
                                } catch (err) {
                                    console.error('Transform error:', err);
                                    alert(`Error: ${err.message}`);
                                }
                            };
                            input.click();
                        },
                        disabled: !inputSchema || !outputSchema || connections.length === 0,
                        title: 'Execute transformation: Upload input file and download transformed output'
                    }, 'üîÑ Execute Transform'),
                    React.createElement('button', {
                        className: 'btn btn-primary',
                        onClick: runAIAutoMap,
                        disabled: !inputSchema || !outputSchema || aiProcessing,
                        title: 'AI analyzes schemas and suggests mappings'
                    }, aiProcessing ? '‚è≥ AI Working...' : 'ü§ñ AI Auto-Map'),
                    React.createElement('button', {
                        className: 'btn btn-success',
                        onClick: runBusinessRulesAutomap,
                        disabled: !inputSchema || !outputSchema,
                        title: 'Automatically match fields with identical business terms'
                    }, 'üìã Business Rules'),
                    React.createElement('button', {
                        className: 'btn btn-primary',
                        onClick: () => setShowSchemaEditor(true),
                        title: 'Visual schema structure builder'
                    }, 'üèóÔ∏è Schema Editor'),
                    React.createElement('button', {
                        className: 'btn btn-secondary',
                        onClick: () => setShowSettings(true),
                        title: 'Configure AI API keys'
                    }, '‚öôÔ∏è Settings'),
                    React.createElement('button', {
                        className: 'btn btn-primary',
                        onClick: saveSessionToBackend,
                        title: 'Save current session to server'
                    }, 'üíæ Save Session'),
                    React.createElement('button', {
                        className: 'btn btn-secondary',
                        onClick: clearSession,
                        title: 'Clear all and start fresh'
                    }, 'üóëÔ∏è Clear Session'),
                    React.createElement('div', { style: { marginLeft: 'auto', fontSize: '13px', color: '#666' } },
                        `${connections.length} connection(s)`,
                        sessionLoaded && React.createElement('span', { 
                            style: { marginLeft: '10px', fontSize: '11px', color: '#4caf50' }
                        }, '‚óè Auto-save active')
                    )
                ),
                React.createElement('div', { className: 'canvas-area', ref: canvasRef },
                    draggedField && React.createElement('div', {
                        style: {
                            position: 'fixed',
                            top: '10px',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            background: '#4caf50',
                            color: 'white',
                            padding: '10px 20px',
                            borderRadius: '6px',
                            fontWeight: 'bold',
                            zIndex: 1000
                        }
                    }, `‚úã Dragging: ${draggedField.field.name} ‚Üí Drop on ${draggedField.type === 'input' ? 'OUTPUT' : 'INPUT'} field`),
                    
                    React.createElement(ConnectionsSVG, {
                        connections,
                        fieldPositions,
                        selectedConnection,
                        setSelectedConnection
                    }),
                    
                    React.createElement('div', { 
                        className: 'canvas-columns'
                    },
                        // INPUT COLUMN
                        React.createElement('div', { 
                            className: 'canvas-column',
                            id: 'input-column',
                            style: { width: '450px' }
                        },
                            React.createElement('h3', {
                                style: { cursor: 'ew-resize', display: 'flex', alignItems: 'center', justifyContent: 'space-between' },  // Always show resize cursor
                                onMouseDown: (e) => {
                                    // Don't trigger resize if clicking the + button
                                    if (e.target.classList.contains('col-import-btn')) return;
                                    e.preventDefault();
                                    console.log('INPUT HEADER DRAG START');
                                    const column = document.getElementById('input-column');
                                    const startX = e.clientX;
                                    const startWidth = column.offsetWidth;
                                    
                                    const onMouseMove = (moveEvent) => {
                                        const delta = moveEvent.clientX - startX;
                                        const newWidth = Math.max(250, Math.min(900, startWidth + delta));
                                        column.style.flex = `0 0 ${newWidth}px`;
                                        column.style.width = newWidth + 'px';
                                        
                                        // Update arrows
                                        requestAnimationFrame(() => {
                                            updateFieldPositions();
                                        });
                                    };
                                    
                                    const onMouseUp = () => {
                                        console.log('INPUT HEADER DRAG END');
                                        document.removeEventListener('mousemove', onMouseMove);
                                        document.removeEventListener('mouseup', onMouseUp);
                                        document.body.style.cursor = '';
                                    };
                                    
                                    document.body.style.cursor = 'ew-resize';
                                    document.addEventListener('mousemove', onMouseMove);
                                    document.addEventListener('mouseup', onMouseUp);
                                }
                            },
                                React.createElement('span', null, 'üì• INPUT SCHEMA'),
                                inputSchema && React.createElement('button', {
                                    className: 'col-import-btn',
                                    title: 'Importa nodi aggiuntivi (CSV/JSON)',
                                    onClick: (e) => { e.stopPropagation(); onOpenNodeImport && onOpenNodeImport('input'); }
                                }, 'Ôºã')
                            ),
                            inputSchema && Object.values(inputSchema.fields)
                                .filter(field => {
                                    if (!hideConnected) return true;
                                    // Hide if field is source of any connection
                                    return !connections.some(conn => 
                                        conn.source === field.id || 
                                        (conn.sources && conn.sources.includes(field.id))
                                    );
                                })
                                .map(field =>
                                React.createElement(FieldBox, {
                                    key: field.id,
                                    field,
                                    type: 'input',
                                    setDraggedField,
                                    draggedField,
                                    dropTarget,
                                    setDropTarget,
                                    handleDrop,
                                    updateFieldPositions,
                                    connections,
                                    inputExample,
                                    outputExample,
                                    inputSchema,
                                    outputSchema,
                                    setHoverPopup,
                                    hoverTimeoutRef,
                                    popupPinned,
                                    setPopupPinned,
                                    selectedConnection,
                                    onFieldContextMenu,
                                    onEditNode,
                                    onDeleteNode
                                })
                            )
                        ),
                        
                        // OUTPUT COLUMN
                        React.createElement('div', { 
                            className: 'canvas-column',
                            id: 'output-column',
                            style: { width: '450px' }
                        },
                            React.createElement('h3', {
                                style: { cursor: 'ew-resize', display: 'flex', alignItems: 'center', justifyContent: 'space-between' },  // Always show resize cursor
                                onMouseDown: (e) => {
                                    if (e.target.classList.contains('col-import-btn')) return;
                                    e.preventDefault();
                                    console.log('OUTPUT HEADER DRAG START');
                                    const column = document.getElementById('output-column');
                                    const startX = e.clientX;
                                    const startWidth = column.offsetWidth;
                                    
                                    const onMouseMove = (moveEvent) => {
                                        const delta = moveEvent.clientX - startX; // Moving right = positive delta
                                        const newWidth = Math.max(250, Math.min(900, startWidth - delta)); // Subtract delta: drag left = wider
                                        column.style.flex = `0 0 ${newWidth}px`;
                                        column.style.width = newWidth + 'px';
                                        
                                        // Update arrows
                                        requestAnimationFrame(() => {
                                            updateFieldPositions();
                                        });
                                    };
                                    
                                    const onMouseUp = () => {
                                        console.log('OUTPUT HEADER DRAG END');
                                        document.removeEventListener('mousemove', onMouseMove);
                                        document.removeEventListener('mouseup', onMouseUp);
                                        document.body.style.cursor = '';
                                    };
                                    
                                    document.body.style.cursor = 'ew-resize';
                                    document.addEventListener('mousemove', onMouseMove);
                                    document.addEventListener('mouseup', onMouseUp);
                                }
                            },
                                React.createElement('span', null, 'üì§ OUTPUT SCHEMA'),
                                outputSchema && React.createElement('button', {
                                    className: 'col-import-btn',
                                    title: 'Importa nodi aggiuntivi (CSV/JSON)',
                                    onClick: (e) => { e.stopPropagation(); onOpenNodeImport && onOpenNodeImport('output'); }
                                }, 'Ôºã')
                            ),
                            outputSchema && Object.values(outputSchema.fields)
                                .filter(field => {
                                    if (!hideConnected) return true;
                                    // Hide if field is target of any connection
                                    return !connections.some(conn => conn.target === field.id);
                                })
                                .map(field =>
                                React.createElement(FieldBox, {
                                    key: field.id,
                                    field,
                                    type: 'output',
                                    setDraggedField,
                                    draggedField,
                                    dropTarget,
                                    setDropTarget,
                                    handleDrop,
                                    updateFieldPositions,
                                    connections,
                                    inputExample,
                                    outputExample,
                                    inputSchema,
                                    outputSchema,
                                    setHoverPopup,
                                    hoverTimeoutRef,
                                    popupPinned,
                                    setPopupPinned,
                                    selectedConnection,
                                    onFieldContextMenu,
                                    onEditNode,
                                    onDeleteNode
                                })
                            )
                        )
                    ),
                    (!inputSchema || !outputSchema) && React.createElement('div', { className: 'empty-state' },
                        React.createElement('div', { style: { fontSize: '64px' } }, 'üìä'),
                        React.createElement('h3', null, 'Upload Schemas to Start'),
                        React.createElement('p', null, 'Upload input & output CSV schemas, then drag to connect')
                    )
                )
            );
        }
        
        function FieldBox({ field, type, setDraggedField, draggedField, dropTarget, setDropTarget, handleDrop, updateFieldPositions, connections, inputExample, outputExample, inputSchema, outputSchema, setHoverPopup, hoverTimeoutRef, popupPinned, setPopupPinned, selectedConnection, onFieldContextMenu, onEditNode, onDeleteNode }) {
            const isConnected = connections.some(c => 
                (type === 'input' && (c.source === field.path || c.source === field.id || c.source === field.name)) ||
                (type === 'output' && (c.target === field.path || c.target === field.id || c.target === field.name))
            );
            
            // DEBUG: Log connection status
            if (type === 'output') {
                console.log('üîç Field:', field.name, 'path:', field.path, 'id:', field.id);
                console.log('üîó isConnected:', isConnected);
                console.log('üìä Total connections:', connections.length);
            }
            
            const isDropTarget = dropTarget === field.id;
            const isDragging = draggedField?.field.id === field.id;
            
            const handleMouseEnter = (e, immediate = false) => {
                console.log('HOVER START on', field.name, 'type:', type, 'immediate:', immediate);
                
                // If popup is pinned, don't do anything on hover
                if (popupPinned && !immediate) return;
                
                if (hoverTimeoutRef.current) {
                    clearTimeout(hoverTimeoutRef.current);
                }
                
                // Capture rect BEFORE setTimeout
                const rect = e.currentTarget.getBoundingClientRect();
                
                const showPopupFn = () => {
                    console.log('SHOWING POPUP for', field.name);
                    
                    if (type === 'input' && inputExample) {
                        // INPUT: Extract context using offset/length or XML path
                        const lines = inputExample.split('\n');
                        let contextLines = [];
                        let highlightIndex = -1;
                        let highlightChar = null;
                        
                        // Detect format
                        const isXML = inputExample.trim().startsWith('<');
                        const isJSON = inputExample.trim().startsWith('{') || inputExample.trim().startsWith('[');
                        const isFlat = !isXML && !isJSON;
                        
                        if (isFlat && field.offset !== undefined && field.length !== undefined) {
                            // IDOC FORMAT: segment pattern + offset + length
                            const segmentName = field.path.split('.')[0]; // E1EDK01
                            const offset = parseInt(field.offset) || 0;
                            const length = parseInt(field.length) || 0;
                            
                            // Find line containing this segment
                            let foundLine = -1;
                            
                            for (let i = 0; i < lines.length; i++) {
                                const line = lines[i];
                                // Check both E1 and E2 prefixes (E1EDK01 might be E2EDK01 in file)
                                const altSegment = segmentName.replace(/^E1/, 'E2');
                                
                                if (line.startsWith(segmentName) || line.startsWith(altSegment)) {
                                    foundLine = i;
                                    break; // Take first occurrence
                                }
                            }
                            
                            if (foundLine >= 0) {
                                // Get 5 lines before and after
                                const start = Math.max(0, foundLine - 5);
                                const end = Math.min(lines.length, foundLine + 6);
                                contextLines = lines.slice(start, end);
                                highlightIndex = foundLine - start;
                                
                                // Highlight EXACTLY offset -> offset+length
                                const line = lines[foundLine];
                                const charStart = offset;
                                const charEnd = Math.min(offset + length, line.length);
                                
                                console.log('HIGHLIGHT CHAR:', {
                                    field: field.name,
                                    segment: segmentName,
                                    line: line.substring(0, 100),
                                    offset: offset,
                                    length: length,
                                    charStart: charStart,
                                    charEnd: charEnd,
                                    extractedValue: line.substring(charStart, charEnd)
                                });
                                
                                highlightChar = { start: charStart, end: charEnd };
                            }
                        } else if ((isXML || isJSON) && (field.xml_path || field.json_path)) {
                            // XML/JSON: Use backend API for extraction
                            console.log('üì° Calling API for XML/JSON extraction:', field.name);
                            
                            const fieldPath = field.xml_path || field.json_path || field.path;
                            const formatType = isXML ? 'xml' : 'json';
                            
                            // Call API asynchronously
                            fetch(`${API_URL}/preview/extract`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    example_content: inputExample,
                                    field_path: fieldPath,
                                    field_name: field.name,
                                    format_type: formatType
                                })
                            })
                            .then(res => res.json())
                            .then(data => {
                                console.log('‚úÖ API Response:', data);
                                
                                if (data.error) {
                                    console.error('API Error:', data.error);
                                    // Show error in popup
                                    setHoverPopup({
                                        field,
                                        type,
                                        rect,
                                        code: `Error: ${data.error}`,
                                        contextLines: [],
                                        highlightIndex: -1
                                    });
                                    return;
                                }
                                
                                // Success - show extracted value
                                const extractedValue = data.value || 'N/A';
                                const code = `<${field.name}>${extractedValue}</${field.name}>`;
                                
                                setHoverPopup({
                                    field,
                                    type,
                                    rect,
                                    code,
                                    contextLines: data.context_lines || [],
                                    highlightIndex: data.highlight_line || -1,
                                    highlightChar: null // XML uses line-level highlighting
                                });
                            })
                            .catch(err => {
                                console.error('API Call Failed:', err);
                                setHoverPopup({
                                    field,
                                    type,
                                    rect,
                                    code: `Error: ${err.message}`,
                                    contextLines: [],
                                    highlightIndex: -1
                                });
                            });
                            
                            // Show loading state immediately
                            setHoverPopup({
                                field,
                                type,
                                rect,
                                code: '‚è≥ Loading...',
                                contextLines: ['Extracting value from ' + formatType.toUpperCase() + '...'],
                                highlightIndex: -1
                            });
                            
                            return; // Exit early - popup will be updated by API response
                        } else {
                            // FALLBACK: Search by field name/path
                            const searchTerms = [field.name, field.path, field.id].filter(Boolean);
                            
                            lines.forEach((line, idx) => {
                                if (searchTerms.some(term => line.includes(term))) {
                                    if (highlightIndex === -1) {
                                        highlightIndex = idx;
                                    }
                                }
                            });
                            
                            if (highlightIndex >= 0) {
                                const start = Math.max(0, highlightIndex - 5);
                                const end = Math.min(lines.length, highlightIndex + 6);
                                contextLines = lines.slice(start, end);
                                highlightIndex = highlightIndex - start;
                            } else {
                                // Show first 11 lines as fallback
                                contextLines = lines.slice(0, Math.min(11, lines.length));
                                highlightIndex = 0;
                            }
                        }
                        
                        setHoverPopup({
                            type: 'input',
                            field: field,
                            lines: contextLines,
                            highlightIndex: highlightIndex,
                            highlightChar: highlightChar,
                            x: rect.right + 10,
                            y: rect.top
                        });
                        
                    } else if (type === 'output' && isConnected) {
                        console.log('OUTPUT HOVER START (CONNECTED)', field.name, 'isConnected:', isConnected);
                        
                        // Helper function to apply transformations
                        const applyTransformation = (value, transType) => {
                            if (!value || typeof value !== 'string') return value;
                            
                            const type = typeof transType === 'string' ? transType.toUpperCase() : '';
                            
                            switch (type) {
                                case 'UPPERCASE':
                                    return value.toUpperCase();
                                case 'LOWERCASE':
                                    return value.toLowerCase();
                                case 'TRIM':
                                    return value.trim();
                                case 'CAPITALIZE':
                                    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
                                case 'DIRECT':
                                    return value;
                                default:
                                    // Unknown transformation type
                                    console.warn('Unknown transformation type:', transType);
                                    return value;
                            }
                        };
                        
                        // OUTPUT: Generate XML code with ACTUAL VALUES from input
                        // FIX: Check both field.path and field.id for matching connections
                        const relatedConns = connections.filter(c => 
                            c.target === field.path || 
                            c.target === field.id ||
                            c.target === field.name
                        );
                        console.log('Related connections:', relatedConns);
                        console.log('Field:', field.path, field.id, field.name);
                        
                        let code = '';
                        
                        // Generate XML from xmlpath
                        const xmlPath = field.xml_path || field.path;
                        const nodeName = xmlPath.split('/').pop();
                        
                        // Function to extract value from input example
                        const extractValueFromInput = async (sourceField, directPath) => {
                            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                            console.log('üîç EXTRACTING VALUE');
                            console.log('üìù sourceField:', sourceField);
                            console.log('üìã inputSchema.fields:', Object.keys(inputSchema?.fields || {}));
                            
                            if (!inputExample || !inputSchema) {
                                console.log('‚ùå No inputExample or inputSchema');
                                return null;
                            }
                            
                            const lines = inputExample.split('\n');
                            
                            // SHORTCUT: if we already have the path from conn.sourcePath, use it directly
                            if (directPath && (inputExample.trim().startsWith('<') || inputExample.trim().startsWith('{'))) {
                                const isXML2 = inputExample.trim().startsWith('<');
                                try {
                                    const resp = await fetch(`${API_URL}/preview/extract`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
                                        body: JSON.stringify({
                                            example_content: inputExample,
                                            field_path: directPath,
                                            field_name: sourceField,
                                            format_type: isXML2 ? 'xml' : 'json'
                                        })
                                    });
                                    const d = await resp.json();
                                    if (d.value !== null && d.value !== undefined && !d.error) {
                                        return d.value;
                                    }
                                } catch(e) {}
                                // If direct path failed, fall through to schema lookup
                            }

                            // Find source field data - try multiple keys
                            let sourceFieldData = null;
                            const possibleKeys = [
                                sourceField,
                                sourceField.replace('.', '_'),
                                sourceField.replace(':', '_'),
                                sourceField.replace(/[.:]/g, '_')
                            ];
                            
                            console.log('üîé Trying keys:', possibleKeys);
                            
                            for (const key of possibleKeys) {
                                if (inputSchema.fields[key]) {
                                    sourceFieldData = inputSchema.fields[key];
                                    console.log('‚úÖ FOUND with key:', key);
                                    console.log('üìÑ Field data:', sourceFieldData);
                                    break;
                                }
                            }
                            
                            // If not found by key, try to find by field.id or field.name
                            if (!sourceFieldData) {
                                console.log('üîé Searching in all fields by id/name/path...');
                                for (const [fieldKey, fieldData] of Object.entries(inputSchema.fields)) {
                                    if (fieldData.id === sourceField || 
                                        fieldData.name === sourceField || 
                                        fieldData.path === sourceField ||
                                        fieldKey === sourceField) {
                                        sourceFieldData = fieldData;
                                        console.log('‚úÖ FOUND field:', fieldKey, '‚Üí', fieldData);
                                        break;
                                    }
                                }
                            }
                            
                            if (!sourceFieldData) {
                                // Last resort: try using sourceField as a path directly
                                const isXML3 = inputExample.trim().startsWith('<');
                                const isJSON3 = inputExample.trim().startsWith('{') || inputExample.trim().startsWith('[');
                                if (isXML3 || isJSON3) {
                                    try {
                                        const resp = await fetch(`${API_URL}/preview/extract`, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json', ...getAuthHeaders() },
                                            body: JSON.stringify({
                                                example_content: inputExample,
                                                field_path: sourceField,
                                                field_name: sourceField,
                                                format_type: isXML3 ? 'xml' : 'json'
                                            })
                                        });
                                        const d = await resp.json();
                                        if (d.value !== null && d.value !== undefined && !d.error) {
                                            return d.value;
                                        }
                                    } catch(e) {}
                                }
                                console.error('‚ùå‚ùå‚ùå FIELD NOT FOUND:', sourceField);
                                return null;
                            }
                            
                            console.log('‚úÖ‚úÖ‚úÖ sourceFieldData:', sourceFieldData);
                            
                            // Detect format
                            const isXML = inputExample.trim().startsWith('<');
                            const isJSON = inputExample.trim().startsWith('{') || inputExample.trim().startsWith('[');
                            
                            if (isXML || isJSON) {
                                // XML/JSON: Use API extraction
                                console.log('üì° Using API for XML/JSON extraction');
                                
                                const fieldPath = sourceFieldData?.xml_path || sourceFieldData?.json_path || sourceFieldData?.path;
                                if (!fieldPath) {
                                    console.log('No path for field');
                                    return null;
                                }
                                
                                try {
                                    const response = await fetch(`${API_URL}/preview/extract`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            example_content: inputExample,
                                            field_path: fieldPath,
                                            field_name: sourceFieldData.name || sourceField,
                                            format_type: isXML ? 'xml' : 'json'
                                        })
                                    });
                                    
                                    const data = await response.json();
                                    
                                    if (data.error) {
                                        console.error('API Error:', data.error);
                                        return null;
                                    }
                                    
                                    console.log('‚úÖ Extracted value from XML/JSON:', data.value);
                                    return data.value;
                                    
                                } catch (err) {
                                    console.error('API call failed:', err);
                                    return null;
                                }
                                
                            } else {
                                // FLAT FILE (IDOC): Use offset/length
                                if (!sourceFieldData || !sourceFieldData.offset || !sourceFieldData.length) {
                                    console.log('Missing offset/length');
                                    return null;
                                }
                                
                                const segmentName = sourceField.split('.')[0];
                                const offset = parseInt(sourceFieldData.offset);
                                const length = parseInt(sourceFieldData.length);
                                
                                // Find line with segment
                                for (let line of lines) {
                                    const altSegment = segmentName.replace(/^E1/, 'E2');
                                    if (line.startsWith(segmentName) || line.startsWith(altSegment)) {
                                        // Extract value at offset
                                        const value = line.substring(offset, offset + length).trim();
                                        console.log('Extracted value:', value, 'from offset', offset, 'length', length);
                                        return value || null;
                                    }
                                }
                                return null;
                            }
                        };
                        
                        if (relatedConns.length === 1) {
                            const conn = relatedConns[0];
                            
                            // Show loading state immediately
                            setHoverPopup({
                                type: 'output',
                                code: '‚è≥ Loading transformation...',
                                field: field,
                                x: rect.left - 410,
                                y: rect.top
                            });
                            
                            // Extract value asynchronously ‚Äî prefer sourcePath if available
                            extractValueFromInput(conn.source, conn.sourcePath).then(value => {
                                console.log('üì• Extracted value:', value);
                                console.log('üîó Connection:', conn);
                                console.log('üîÑ Transformation object:', conn.transformation);
                                
                                if (!value) {
                                    // NO FALLBACK to field name! Use placeholder instead
                                    console.warn('‚ö†Ô∏è Could not extract value from input example for:', conn.source);
                                    value = 'VALUE_NOT_FOUND';
                                }
                                
                                // Apply transformation to the extracted value
                                let transformedValue = value;
                                
                                if (conn.transformation) {
                                    // Check what type of transformation object we have
                                    if (typeof conn.transformation === 'string') {
                                        // Simple string transformation type
                                        transformedValue = applyTransformation(value, conn.transformation);
                                    } else if (conn.transformation.formula) {
                                        // Has custom formula - show formula (can't evaluate dynamically)
                                        transformedValue = `\${${conn.transformation.formula}}`;
                                    } else if (conn.transformation.type && typeof conn.transformation.type === 'string' && conn.transformation.type !== 'direct') {
                                        // Built-in transformation with type property
                                        transformedValue = applyTransformation(value, conn.transformation.type);
                                    } else if (conn.transformation.operation) {
                                        // Complex transformation object with operation, inputs, etc.
                                        // For now, show a placeholder (can't evaluate complex transformations)
                                        transformedValue = `\${${conn.transformation.operation}(...)}`;
                                    } else {
                                        // Unknown transformation format, use value as-is
                                        console.warn('Unknown transformation format:', conn.transformation);
                                        transformedValue = value;
                                    }
                                }
                                
                                console.log('Final transformed value:', transformedValue);
                                
                                let code = '';
                                const xmlPath = field.xml_path || field.path;
                                const nodeName = xmlPath.split('/').pop();
                                
                                // Generate XML with transformed value
                                code = `<${nodeName}>${transformedValue}</${nodeName}>`;
                                
                                // Add parent context if available
                                const pathParts = xmlPath.split('/').filter(p => p);
                                if (pathParts.length > 1) {
                                    const parentNode = pathParts[pathParts.length - 2];
                                    code = `<${parentNode}>\n  ${code}\n</${parentNode}>`;
                                }
                                
                                console.log('Generated code:', code);
                                
                                // Update popup with actual code
                                setHoverPopup({
                                    type: 'output',
                                    code: code,
                                    field: field,
                                    connections: relatedConns,
                                    x: rect.left - 410,
                                    y: rect.top
                                });
                            }).catch(err => {
                                console.error('Extraction failed:', err);
                                // Show error popup
                                setHoverPopup({
                                    type: 'output',
                                    code: `‚ùå Error: ${err.message}`,
                                    field: field,
                                    x: rect.left - 410,
                                    y: rect.top
                                });
                            });
                            
                            // Exit early - popup will be updated by promise
                            
                        } else if (relatedConns.length > 1) {
                            // Multiple inputs - show loading
                            setHoverPopup({
                                type: 'output',
                                code: '‚è≥ Loading transformation...',
                                field: field,
                                x: rect.left - 410,
                                y: rect.top
                            });
                            
                            // Extract all values asynchronously
                            Promise.all(relatedConns.map(c => extractValueFromInput(c.source)))
                                .then(extractedValues => {
                                    const values = extractedValues.map((val, i) => 
                                        val || relatedConns[i].sourceName || relatedConns[i].source
                                    ).join(' ');
                                    
                                    const xmlPath = field.xml_path || field.path;
                                    const nodeName = xmlPath.split('/').pop();
                                    let code = `<${nodeName}>${values}</${nodeName}>`;
                                    
                                    // Add parent context
                                    const pathParts = xmlPath.split('/').filter(p => p);
                                    if (pathParts.length > 1) {
                                        const parentNode = pathParts[pathParts.length - 2];
                                        code = `<${parentNode}>\n  ${code}\n</${parentNode}>`;
                                    }
                                    
                                    console.log('Generated code (multiple):', code);
                                    
                                    setHoverPopup({
                                        type: 'output',
                                        code: code,
                                        field: field,
                                        connections: relatedConns,
                                        x: rect.left - 410,
                                        y: rect.top
                                    });
                                })
                                .catch(err => {
                                    console.error('Extraction failed:', err);
                                    setHoverPopup({
                                        type: 'output',
                                        code: `‚ùå Error: ${err.message}`,
                                        field: field,
                                        x: rect.left - 410,
                                        y: rect.top
                                    });
                                });
                            
                            // Exit early - popup updated by promise
                            
                        } else {
                            // No connection yet
                            const xmlPath = field.xml_path || field.path;
                            const nodeName = xmlPath.split('/').pop();
                            let code = `<${nodeName}>TO_BE_MAPPED</${nodeName}>`;
                            
                            // Add parent context if available
                            const pathParts = xmlPath.split('/').filter(p => p);
                            if (pathParts.length > 1) {
                                const parentNode = pathParts[pathParts.length - 2];
                                code = `<${parentNode}>\n  ${code}\n</${parentNode}>`;
                            }
                            
                            setHoverPopup({
                                type: 'output',
                                code: code,
                                field: field,
                                connections: relatedConns,
                                x: rect.left - 410,
                                y: rect.top
                            });
                        }
                    } else if (type === 'output' && !isConnected && outputExample) {
                        // OUTPUT NOT CONNECTED: Show structure from example
                        console.log('OUTPUT HOVER (NO CONNECTION) - Showing structure from example');
                        
                        const xmlPath = field.xml_path || field.path;
                        const nodeName = xmlPath.split('/').pop();
                        
                        // Try to extract structure from output example
                        const isXML = outputExample.trim().startsWith('<');
                        
                        if (isXML) {
                            // Extract this node from output example
                            try {
                                const regex = new RegExp(`<${nodeName}[^>]*>([\\s\\S]*?)<\\/${nodeName}>`, 'i');
                                const match = outputExample.match(regex);
                                
                                if (match) {
                                    let code = match[0];
                                    
                                    setHoverPopup({
                                        type: 'output',
                                        code: code,
                                        field: field,
                                        connections: [],
                                        x: rect.left - 410,
                                        y: rect.top
                                    });
                                } else {
                                    // No match in example, show placeholder
                                    let code = `<${nodeName}>TO_BE_MAPPED</${nodeName}>`;
                                    
                                    const pathParts = xmlPath.split('/').filter(p => p);
                                    if (pathParts.length > 1) {
                                        const parentNode = pathParts[pathParts.length - 2];
                                        code = `<${parentNode}>\n  ${code}\n</${parentNode}>`;
                                    }
                                    
                                    setHoverPopup({
                                        type: 'output',
                                        code: code,
                                        field: field,
                                        connections: [],
                                        x: rect.left - 410,
                                        y: rect.top
                                    });
                                }
                            } catch (err) {
                                console.error('Error extracting structure:', err);
                                // Fallback to simple placeholder
                                setHoverPopup({
                                    type: 'output',
                                    code: `<${nodeName}>STRUCTURE</${nodeName}>`,
                                    field: field,
                                    connections: [],
                                    x: rect.left - 410,
                                    y: rect.top
                                });
                            }
                        } else {
                            // Non-XML output, show simple placeholder
                            let code = `<${nodeName}>TO_BE_MAPPED</${nodeName}>`;
                            
                            setHoverPopup({
                                type: 'output',
                                code: code,
                                field: field,
                                connections: [],
                                x: rect.left - 410,
                                y: rect.top
                            });
                        }
                    }
                };
                
                // Show immediately on click, or after 2s on hover
                if (immediate) {
                    showPopupFn();
                } else {
                    hoverTimeoutRef.current = setTimeout(showPopupFn, 2000);
                }
            };
            
            const handleMouseLeave = () => {
                // Don't hide popup if it's pinned
                if (popupPinned) return;
                
                if (hoverTimeoutRef.current) {
                    clearTimeout(hoverTimeoutRef.current);
                }
                setHoverPopup(null);
            };
            
            const handleFieldClick = (e) => {
                // Single click: show popup immediately and pin it
                if (hoverTimeoutRef.current) {
                    clearTimeout(hoverTimeoutRef.current);
                }
                
                // Trigger the hover popup immediately
                handleMouseEnter(e, true); // Pass immediate=true
                setPopupPinned(true);
                updateFieldPositions();
            };
            
            // Check if this field is part of selected connection
            const isHighlighted = selectedConnection && (
                (selectedConnection.source === field.id) ||
                (selectedConnection.sources && selectedConnection.sources.includes(field.id)) ||
                (selectedConnection.target === field.id)
            );
            
            return React.createElement('div', {
                className: `field-box ${field.required ? 'required' : ''} ${field.calculation ? 'calculated' : ''} ${isDragging ? 'dragging' : ''} ${isDropTarget ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}`,
                'data-field-id': `${type}-${field.id}`,
                draggable: true,
                onDragStart: (e) => {
                    setDraggedField({ field, type });
                    e.dataTransfer.effectAllowed = 'link';
                },
                onDragEnd: () => {
                    setDraggedField(null);
                    setDropTarget(null);
                },
                onDragOver: (e) => {
                    if (draggedField && draggedField.type !== type) {
                        e.preventDefault();
                        setDropTarget(field.id);
                    }
                },
                onDragLeave: () => {
                    setDropTarget(null);
                },
                onDrop: (e) => {
                    e.preventDefault();
                    handleDrop(field, type);
                },
                onClick: handleFieldClick,
                onMouseEnter: (e) => handleMouseEnter(e, false),
                onMouseLeave: handleMouseLeave
            },
                // Edit / Delete buttons (visible on hover)
                (onEditNode || onDeleteNode) && React.createElement('div', {
                    className: 'field-box-actions',
                    onClick: e => e.stopPropagation(),
                    onMouseDown: e => e.stopPropagation(),
                    draggable: false,
                    onDragStart: e => e.preventDefault()
                },
                    onEditNode && React.createElement('button', {
                        className: 'field-action-btn edit',
                        title: 'Modifica nodo',
                        onClick: (e) => { e.stopPropagation(); e.preventDefault(); onEditNode(field, type); }
                    }, '‚úèÔ∏è'),
                    onDeleteNode && React.createElement('button', {
                        className: 'field-action-btn delete',
                        title: 'Elimina nodo',
                        onClick: (e) => { e.stopPropagation(); e.preventDefault(); onDeleteNode(field, type); }
                    }, 'üóëÔ∏è')
                ),
                React.createElement('div', { className: 'field-name' },
                    isConnected && (type === 'input' ? '‚Üí ' : '‚Üê '),
                    field.name
                ),
                field.business_term && React.createElement('div', { className: 'field-business' },
                    field.business_term
                ),
                React.createElement('div', { className: 'field-meta' },
                    React.createElement('span', { className: 'field-badge', style: { background: '#e3f2fd' } }, field.type),
                    React.createElement('span', { className: 'field-badge', style: { background: '#f3e5f5' } }, field.cardinality),
                    field.calculation && React.createElement('span', { className: 'field-badge', style: { background: '#fff3cd' } }, 'üìê ' + field.calculation.substring(0, 15)),
                    field.offset && React.createElement('span', { className: 'field-badge', style: { background: '#e8f5e9' } }, 'üìç ' + field.offset),
                    field.length && React.createElement('span', { className: 'field-badge', style: { background: '#fce4ec' } }, 'üìè ' + field.length),
                    field.xml_path && React.createElement('span', { className: 'field-badge', style: { background: '#fff9c4', fontSize: '9px' }, title: field.xml_path }, 'üåê ' + field.xml_path.substring(field.xml_path.lastIndexOf('/') + 1))
                )
            );
        }
        
        function ConnectionsSVG({ connections, fieldPositions, selectedConnection, setSelectedConnection }) {
            if (connections.length === 0) return null;
            
            return React.createElement('svg', { className: 'connections' },
                connections.map(conn => {
                    // Handle both single source and multiple sources (for CONCAT)
                    const sourceId = conn.source || (conn.sources && conn.sources[0]);
                    const targetId = conn.target;
                    
                    if (!sourceId || !targetId) return null;
                    
                    const sourcePos = fieldPositions[`input-${sourceId.replace(/\./g, '_')}`];
                    const targetPos = fieldPositions[`output-${targetId.replace(/\./g, '_')}`];
                    
                    if (!sourcePos || !targetPos) return null;
                    
                    const isSelected = selectedConnection?.id === conn.id;
                    const pathD = `M ${sourcePos.x} ${sourcePos.y} C ${sourcePos.x + 20} ${sourcePos.y}, ${targetPos.x - 20} ${targetPos.y}, ${targetPos.x} ${targetPos.y}`;
                    
                    return React.createElement('g', { key: conn.id },
                        React.createElement('path', {
                            d: pathD,
                            className: `connection-line ${isSelected ? 'selected' : ''}`,
                            onClick: (e) => {
                                e.stopPropagation();
                                setSelectedConnection(conn);
                            },
                            onDoubleClick: (e) => {
                                e.stopPropagation();
                                if (confirm(`Eliminare collegamento ${conn.sourceName} ‚Üí ${conn.targetName}?`)) {
                                    setSelectedConnection(null);
                                    // Trigger delete (pass to parent)
                                    window.deleteConnectionCallback?.(conn.id);
                                }
                            },
                            style: { cursor: 'pointer' }
                        }),
                        React.createElement('polygon', {
                            className: 'connection-arrow',
                            points: `${targetPos.x},${targetPos.y} ${targetPos.x-10},${targetPos.y-5} ${targetPos.x-10},${targetPos.y+5}`,
                            style: { fill: isSelected ? '#f44336' : '#00BCD4', cursor: 'pointer' },
                            onDoubleClick: (e) => {
                                e.stopPropagation();
                                if (confirm(`Eliminare collegamento ${conn.sourceName} ‚Üí ${conn.targetName}?`)) {
                                    setSelectedConnection(null);
                                    window.deleteConnectionCallback?.(conn.id);
                                }
                            }
                        })
                    );
                })
            );
        }
        
        // ===================================================
        // NODE IMPORT MODAL
        // ===================================================
        function NodeImportModal({ direction, schemaType, onClose, onImport }) {
            const [file, setFile] = useState(null);
            const [fileType, setFileType] = useState('csv');
            const [isDragging, setIsDragging] = useState(false);
            const [preview, setPreview] = useState(null);
            const [error, setError] = useState('');
            const fileInputRef = useRef(null);

            const isXML = schemaType === 'xml' || schemaType === 'xsd';

            const parseCSV = (text) => {
                const lines = text.trim().split('\n').filter(l => l.trim());
                if (lines.length < 2) throw new Error('CSV must have header + at least one row');
                const headers = lines[0].split(',').map(h => h.replace(/"/g,'').trim());
                return lines.slice(1).map(line => {
                    const vals = line.split(',').map(v => v.replace(/"/g,'').trim());
                    const obj = {};
                    headers.forEach((h, i) => obj[h] = vals[i] || '');
                    return obj;
                });
            };

            const parseJSON = (text) => {
                const data = JSON.parse(text);
                if (Array.isArray(data)) return data;
                if (data.fields) return Array.isArray(data.fields) ? data.fields : Object.values(data.fields);
                return [data];
            };

            const handleFileSelect = async (selectedFile) => {
                setFile(selectedFile);
                setError('');
                setPreview(null);
                try {
                    const text = await selectedFile.text();
                    let rows;
                    const ext = selectedFile.name.split('.').pop().toLowerCase();
                    if (ext === 'json') {
                        rows = parseJSON(text);
                        setFileType('json');
                    } else {
                        rows = parseCSV(text);
                        setFileType('csv');
                    }
                    setPreview(rows.slice(0, 5));
                } catch(e) {
                    setError('Parse error: ' + e.message);
                }
            };

            const handleImport = async () => {
                if (!file) return;
                try {
                    const text = await file.text();
                    let rows;
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (ext === 'json') {
                        rows = parseJSON(text);
                    } else {
                        rows = parseCSV(text);
                    }
                    onImport(rows, direction);
                    onClose();
                } catch(e) {
                    setError('Import error: ' + e.message);
                }
            };

            return React.createElement('div', { className: 'modal-overlay', onClick: onClose },
                React.createElement('div', {
                    className: 'node-import-modal',
                    onClick: e => e.stopPropagation()
                },
                    // Header
                    React.createElement('div', {
                        style: {
                            padding: '18px 20px',
                            background: 'linear-gradient(135deg, #00BCD4 0%, #3F51B5 100%)',
                            color: 'white',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }
                    },
                        React.createElement('h3', null,
                            `üì• Importa Nodi Aggiuntivi ‚Äî ${direction.toUpperCase()}`
                        ),
                        React.createElement('button', {
                            onClick: onClose,
                            style: { background: 'none', border: 'none', color: 'white', fontSize: '20px', cursor: 'pointer' }
                        }, '√ó')
                    ),



                    // Body
                    React.createElement('div', { style: { padding: '20px', overflowY: 'auto', flex: 1 } },
                        React.createElement('p', { style: { fontSize: '13px', color: '#555', marginBottom: '16px' } },
                            'Carica un file CSV o JSON con la stessa struttura dello schema corrente. I nodi importati appariranno come un pacchetto trascinabile da posizionare nello schema XML.'
                        ),

                        // Drop area
                        React.createElement('div', {
                            style: {
                                border: isDragging ? '3px dashed #00BCD4' : '2px dashed #ccc',
                                borderRadius: '8px',
                                padding: '24px',
                                textAlign: 'center',
                                background: isDragging ? '#e0f7fa' : '#fafafa',
                                cursor: 'pointer',
                                marginBottom: '16px',
                                transition: 'all 0.2s'
                            },
                            onClick: () => fileInputRef.current?.click(),
                            onDragOver: e => { e.preventDefault(); setIsDragging(true); },
                            onDragLeave: () => setIsDragging(false),
                            onDrop: e => {
                                e.preventDefault();
                                setIsDragging(false);
                                const f = e.dataTransfer.files[0];
                                if (f) handleFileSelect(f);
                            }
                        },
                            file
                                ? React.createElement('div', null,
                                    React.createElement('div', { style: { fontSize: '36px' } }, '‚úÖ'),
                                    React.createElement('div', { style: { fontWeight: 'bold', marginTop: '6px' } }, file.name)
                                )
                                : React.createElement('div', null,
                                    React.createElement('div', { style: { fontSize: '36px' } }, isDragging ? 'üìÇ' : 'üìÅ'),
                                    React.createElement('div', { style: { marginTop: '8px', color: '#666' } }, 'Clicca o trascina qui un file CSV o JSON')
                                ),
                            React.createElement('input', {
                                ref: fileInputRef,
                                type: 'file',
                                style: { display: 'none' },
                                accept: '.csv,.json',
                                onChange: e => e.target.files[0] && handleFileSelect(e.target.files[0])
                            })
                        ),

                        // Error
                        error && React.createElement('div', {
                            style: { color: '#f44336', fontSize: '13px', marginBottom: '12px', padding: '8px', background: '#ffebee', borderRadius: '4px' }
                        }, error),

                        // Preview
                        preview && preview.length > 0 && React.createElement('div', { style: { marginBottom: '16px' } },
                            React.createElement('div', {
                                style: { fontWeight: '600', fontSize: '13px', marginBottom: '8px', color: '#333' }
                            }, `Anteprima (${preview.length} su ${preview.length} righe):`)  ,
                            React.createElement('div', {
                                style: { overflowX: 'auto', border: '1px solid #ddd', borderRadius: '6px', fontSize: '11px' }
                            },
                                React.createElement('table', { style: { width: '100%', borderCollapse: 'collapse' } },
                                    React.createElement('thead', null,
                                        React.createElement('tr', { style: { background: '#f5f5f5' } },
                                            Object.keys(preview[0]).slice(0,6).map(k =>
                                                React.createElement('th', {
                                                    key: k,
                                                    style: { padding: '6px 8px', borderBottom: '1px solid #ddd', textAlign: 'left', whiteSpace: 'nowrap' }
                                                }, k)
                                            )
                                        )
                                    ),
                                    React.createElement('tbody', null,
                                        preview.map((row, i) =>
                                            React.createElement('tr', { key: i, style: { borderBottom: '1px solid #f0f0f0' } },
                                                Object.values(row).slice(0,6).map((v, j) =>
                                                    React.createElement('td', {
                                                        key: j,
                                                        style: { padding: '5px 8px', maxWidth: '100px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }
                                                    }, String(v))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    // Footer
                    React.createElement('div', {
                        style: { padding: '14px 20px', borderTop: '1px solid #eee', display: 'flex', gap: '10px', justifyContent: 'flex-end' }
                    },
                        React.createElement('button', { className: 'btn btn-secondary', onClick: onClose }, 'Annulla'),
                        React.createElement('button', {
                            className: 'btn btn-primary',
                            onClick: handleImport,
                            disabled: !file || !!error
                        }, 'üì¶ Importa come Pacchetto')
                    )
                )
            );
        }

        // ===================================================
        // NODE BUNDLE (draggable package of nodes)
        // ===================================================
        function NodeBundle({ bundle, onDrop, onDismiss }) {
            const [pos, setPos] = useState({ x: 80, y: 200 });
            const [dragging, setDragging] = useState(false);
            const [dropZoneActive, setDropZoneActive] = useState(false);
            const dragOffset = useRef({ x: 0, y: 0 });
            const bundleRef = useRef(null);

            const handleMouseDown = (e) => {
                e.preventDefault();
                setDragging(true);
                dragOffset.current = {
                    x: e.clientX - pos.x,
                    y: e.clientY - pos.y
                };

                const onMove = (me) => {
                    setPos({ x: me.clientX - dragOffset.current.x, y: me.clientY - dragOffset.current.y });

                    // Check if hovering over a field-box
                    const els = document.elementsFromPoint(me.clientX, me.clientY);
                    const onField = els.some(el => el.classList.contains('field-box'));
                    setDropZoneActive(onField);
                };

                const onUp = (ue) => {
                    setDragging(false);
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);

                    // Check drop target
                    const els = document.elementsFromPoint(ue.clientX, ue.clientY);
                    const fieldEl = els.find(el => el.classList.contains('field-box') && el.dataset.fieldId);
                    if (fieldEl) {
                        const fieldId = fieldEl.dataset.fieldId;
                        const colType = fieldId.startsWith('input-') ? 'input' : 'output';
                        onDrop(bundle, fieldId, colType);
                    }
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            };

            return React.createElement('div', {
                ref: bundleRef,
                className: 'node-bundle',
                style: {
                    left: pos.x + 'px',
                    top: pos.y + 'px',
                    outline: dropZoneActive ? '2px solid #4caf50' : 'none',
                    background: dropZoneActive ? '#e8f5e9' : 'white'
                },
                onMouseDown: handleMouseDown
            },
                React.createElement('div', { className: 'node-bundle-title' },
                    'üì¶ Pacchetto',
                    React.createElement('span', { className: 'node-bundle-count' }, bundle.nodes.length + ' nodi'),
                    React.createElement('span', {
                        style: { marginLeft: 'auto', cursor: 'pointer', color: '#999', fontSize: '16px', fontWeight: 'normal' },
                        onClick: (e) => { e.stopPropagation(); onDismiss(bundle.id); }
                    }, '√ó')
                ),
                React.createElement('ul', { className: 'node-bundle-list' },
                    bundle.nodes.slice(0, 6).map((n, i) =>
                        React.createElement('li', { key: i }, n.name || n.field_name || n.Field_Name || Object.values(n)[0])
                    ),
                    bundle.nodes.length > 6 && React.createElement('li', { key: 'more', style: { color: '#999', fontStyle: 'italic' } },
                        `... e altri ${bundle.nodes.length - 6}`
                    )
                ),
                React.createElement('div', { className: 'node-bundle-drop-hint' },
                    dropZoneActive ? '‚úÖ Rilascia qui per inserire dopo questo nodo' : '‚òùÔ∏è Trascina su un nodo per inserirlo dopo'
                )
            );
        }

        // ===================================================
        // FIELD CONTEXT MENU
        // ===================================================
        function FieldContextMenu({ x, y, field, colType, onEdit, onDelete, onClose }) {
            useEffect(() => {
                // Use mousedown on capture so we catch clicks outside AFTER the menu has rendered
                const handler = (e) => {
                    // If click is not inside context menu, close
                    const menu = document.querySelector('.field-context-menu');
                    if (menu && !menu.contains(e.target)) {
                        onClose();
                    }
                };
                // Delay adding listener so the right-click event that opened the menu doesn't immediately close it
                const t = setTimeout(() => {
                    document.addEventListener('mousedown', handler);
                }, 100);
                return () => {
                    clearTimeout(t);
                    document.removeEventListener('mousedown', handler);
                };
            }, []);

            // Adjust position so menu doesn't go off screen
            const menuStyle = {
                left: Math.min(x, window.innerWidth - 180) + 'px',
                top: Math.min(y, window.innerHeight - 100) + 'px'
            };

            return React.createElement('div', {
                className: 'field-context-menu',
                style: menuStyle,
                onMouseDown: e => e.stopPropagation()
            },
                React.createElement('div', {
                    className: 'field-context-menu-item',
                    onMouseDown: (e) => {
                        e.stopPropagation();
                        onClose();
                        setTimeout(() => onEdit(field, colType), 0);
                    }
                }, React.createElement('span', null, '‚úèÔ∏è'), ' Modifica nodo'),
                React.createElement('div', { className: 'field-context-menu-separator' }),
                React.createElement('div', {
                    className: 'field-context-menu-item danger',
                    onMouseDown: (e) => {
                        e.stopPropagation();
                        onClose();
                        setTimeout(() => onDelete(field, colType), 0);
                    }
                }, React.createElement('span', null, 'üóëÔ∏è'), ' Elimina nodo')
            );
        }

        // ===================================================
        // NODE EDIT MODAL
        // ===================================================
        function NodeEditModal({ field, colType, onSave, onClose }) {
            const [form, setForm] = useState({
                name: field.name || '',
                type: field.type || 'string',
                cardinality: field.cardinality || '0..1',
                business_term: field.business_term || '',
                description: field.description || '',
                required: field.required || false
            });

            const set = (k, v) => setForm(f => ({ ...f, [k]: v }));

            return React.createElement('div', { className: 'modal-overlay', onClick: onClose },
                React.createElement('div', {
                    className: 'node-edit-modal',
                    onClick: e => e.stopPropagation(),
                    style: { padding: '0' }
                },
                    // Header
                    React.createElement('div', {
                        style: {
                            padding: '16px 20px',
                            background: 'linear-gradient(135deg, #00BCD4 0%, #3F51B5 100%)',
                            color: 'white',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            borderRadius: '12px 12px 0 0'
                        }
                    },
                        React.createElement('h3', null, `‚úèÔ∏è Modifica Nodo ‚Äî ${field.name}`),
                        React.createElement('button', {
                            onClick: onClose,
                            style: { background: 'none', border: 'none', color: 'white', fontSize: '20px', cursor: 'pointer' }
                        }, '√ó')
                    ),
                    // Body
                    React.createElement('div', { style: { padding: '20px' } },
                        [
                            ['Nome campo', 'name', 'text'],
                            ['Tipo dati', 'type', 'select', ['string', 'integer', 'decimal', 'boolean', 'date', 'datetime', 'element']],
                            ['Cardinalit√†', 'cardinality', 'select', ['0..1', '1..1', '0..n', '1..n']],
                            ['Business Term', 'business_term', 'text'],
                            ['Descrizione', 'description', 'text']
                        ].map(([label, key, inputType, opts]) =>
                            React.createElement('div', { key: key, className: 'form-group', style: { marginBottom: '14px' } },
                                React.createElement('label', { style: { display: 'block', fontWeight: '600', fontSize: '13px', marginBottom: '5px' } }, label),
                                inputType === 'select'
                                    ? React.createElement('select', {
                                        value: form[key],
                                        onChange: e => set(key, e.target.value),
                                        style: { width: '100%' }
                                    },
                                        opts.map(o => React.createElement('option', { key: o, value: o }, o))
                                    )
                                    : React.createElement('input', {
                                        type: 'text',
                                        value: form[key],
                                        onChange: e => set(key, e.target.value),
                                        style: { width: '100%' }
                                    })
                            )
                        ),
                        React.createElement('label', { style: { display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' } },
                            React.createElement('input', {
                                type: 'checkbox',
                                checked: form.required,
                                onChange: e => set('required', e.target.checked)
                            }),
                            React.createElement('span', { style: { fontWeight: '600', fontSize: '13px' } }, 'Campo obbligatorio')
                        )
                    ),
                    // Footer
                    React.createElement('div', {
                        style: { padding: '14px 20px', borderTop: '1px solid #eee', display: 'flex', gap: '10px', justifyContent: 'flex-end' }
                    },
                        React.createElement('button', { className: 'btn btn-secondary', onClick: onClose }, 'Annulla'),
                        React.createElement('button', {
                            className: 'btn btn-success',
                            onClick: () => { onSave({ ...field, ...form }, colType); onClose(); }
                        }, '‚úÖ Salva')
                    )
                )
            );
        }

        function ConnectionsList({ connections, selectedConnection, setSelectedConnection }) {
            if (connections.length === 0) {
                return React.createElement('div', { className: 'empty-state' },
                    React.createElement('p', null, 'No connections yet'),
                    React.createElement('small', null, 'Drag input fields to output fields')
                );
            }
            
            return React.createElement('div', null,
                connections.map(conn =>
                    React.createElement('div', {
                        key: conn.id,
                        className: `connection-list-item ${selectedConnection?.id === conn.id ? 'selected' : ''}`,
                        onClick: () => setSelectedConnection(conn)
                    },
                        React.createElement('div', { style: { fontSize: '11px', color: '#4caf50', fontWeight: 'bold' } },
                            'üì• ' + conn.source
                        ),
                        React.createElement('div', { style: { fontSize: '11px', color: '#2196f3', fontWeight: 'bold', marginTop: '4px' } },
                            'üì§ ' + conn.target
                        ),
                        React.createElement('div', { style: { fontSize: '10px', color: '#666', marginTop: '4px' } },
                            '‚öôÔ∏è ' + conn.transformation.type
                        )
                    )
                )
            );
        }
        
        function FormulaParamsPanel({ transType, params, onChange }) {
            // Helper: generic text input row
            const row = (label, key, placeholder, type='text') =>
                React.createElement('div', { className: 'form-group', key: key },
                    React.createElement('label', null, label),
                    React.createElement('input', {
                        type,
                        value: params[key] || '',
                        placeholder,
                        onChange: e => onChange({ ...params, [key]: e.target.value })
                    })
                );

            const select = (label, key, options) =>
                React.createElement('div', { className: 'form-group', key: key },
                    React.createElement('label', null, label),
                    React.createElement('select', {
                        value: params[key] || options[0].value,
                        onChange: e => onChange({ ...params, [key]: e.target.value })
                    }, options.map(o => React.createElement('option', { key: o.value, value: o.value }, o.label)))
                );

            const hint = (text) =>
                React.createElement('div', { style: { fontSize: '11px', color: '#888', background: '#f9f9f9', padding: '8px 10px', borderRadius: '4px', marginBottom: '8px' } }, text);

            const t = (transType || '').toUpperCase();

            if (t === 'DIRECT') return React.createElement('div', { style: { fontSize: '12px', color: '#888', padding: '8px 0' } }, '‚Üí Nessun parametro: il valore viene copiato cos√¨ com\'√®.');

            if (t === 'CONCAT') return React.createElement('div', null,
                hint('Unisce pi√π valori. Trascina pi√π campi sorgente sulla stessa destinazione per abilitare il multi-source.'),
                row('Separatore', 'separator', 'es: " " oppure "-" oppure ""')
            );

            if (t === 'SPLIT') return React.createElement('div', null,
                hint('Estrae una parte da una stringa usando un delimitatore o regex.'),
                row('Delimitatore', 'delimiter', 'es: "/" oppure "-" oppure " "'),
                row('Indice parte (0=prima)', 'index', '0', 'number'),
                row('Oppure: Regex (avanzato)', 'regex', 'es: (\\d{4})-(\\d{2})'),
                row('Gruppo regex', 'group', '1', 'number')
            );

            if (t === 'DATE_FORMAT') return React.createElement('div', null,
                hint('Converte il formato data. Usa strftime: %Y=anno, %m=mese, %d=giorno, %H=ora, %M=minuti.'),
                row('Formato input', 'from_format', 'es: %Y%m%d oppure %d/%m/%Y'),
                row('Formato output', 'to_format', 'es: %Y-%m-%d oppure %d.%m.%Y')
            );

            if (t === 'MATH') return React.createElement('div', null,
                hint('Operazione aritmetica sul valore numerico del campo sorgente.'),
                select('Operazione', 'operation', [
                    { value: 'add',       label: '+ Addizione' },
                    { value: 'subtract',  label: '- Sottrazione' },
                    { value: 'multiply',  label: '√ó Moltiplicazione' },
                    { value: 'divide',    label: '√∑ Divisione' },
                    { value: 'round',     label: '‚âà Arrotonda' },
                    { value: 'abs',       label: '| | Valore assoluto' },
                    { value: 'negate',    label: '‚àí Negazione' },
                ]),
                row('Operando (es: 100)', 'operand', '100', 'number'),
                row('Decimali (solo per round)', 'decimals', '2', 'number')
            );

            if (t === 'LOOKUP') return React.createElement('div', null,
                hint('Traduce codici tramite una tabella. Inserisci il JSON della tabella sotto.'),
                React.createElement('div', { className: 'form-group' },
                    React.createElement('label', null, 'Tabella (JSON)'),
                    React.createElement('textarea', {
                        style: { width: '100%', minHeight: '90px', fontFamily: 'monospace', fontSize: '12px', padding: '8px', border: '1px solid #ddd', borderRadius: '4px', resize: 'vertical' },
                        value: params.table_raw || (params.table ? JSON.stringify(params.table, null, 2) : ''),
                        placeholder: '{"IT": "380", "DE": "380", "FR": "380"}',
                        onChange: e => {
                            try { onChange({ ...params, table: JSON.parse(e.target.value), table_raw: e.target.value }); }
                            catch(_) { onChange({ ...params, table_raw: e.target.value }); }
                        }
                    })
                ),
                row('Valore default se non trovato', 'default', 'es: 380')
            );

            if (t === 'CONDITIONAL') return React.createElement('div', null,
                hint('Condizioni if/then. Inserisci le regole come JSON array.'),
                React.createElement('div', { className: 'form-group' },
                    React.createElement('label', null, 'Condizioni (JSON)'),
                    React.createElement('textarea', {
                        style: { width: '100%', minHeight: '110px', fontFamily: 'monospace', fontSize: '12px', padding: '8px', border: '1px solid #ddd', borderRadius: '4px', resize: 'vertical' },
                        value: params.conditions_raw || (params.conditions ? JSON.stringify(params.conditions, null, 2) : ''),
                        placeholder: '[{"if": {"equals": "RE"}, "then": "381"}]',
                        onChange: e => {
                            try { onChange({ ...params, conditions: JSON.parse(e.target.value), conditions_raw: e.target.value }); }
                            catch(_) { onChange({ ...params, conditions_raw: e.target.value }); }
                        }
                    })
                ),
                row('Valore default (nessuna condizione)', 'default', 'es: 380')
            );

            if (t === 'STRING_OP') {
                const op = params.operation || 'upper';
                const extraFields = [];
                if (op === 'replace')       { extraFields.push(row('Trova', 'find', 'es: .')); extraFields.push(row('Sostituisci con', 'replace_with', 'es: ,')); }
                if (op === 'substring')     { extraFields.push(row('Inizio (0-based)', 'start', '0', 'number')); extraFields.push(row('Fine (escluso)', 'end', '8', 'number')); }
                if (op === 'pad_left' || op === 'pad_right') { extraFields.push(row('Larghezza totale', 'width', '10', 'number')); extraFields.push(row('Carattere riempimento', 'char', '0')); }
                if (op === 'remove_prefix') extraFields.push(row('Prefisso da rimuovere', 'prefix', 'es: IT'));
                if (op === 'remove_suffix') extraFields.push(row('Suffisso da rimuovere', 'suffix', 'es: .xml'));
                if (op === 'regex_replace') { extraFields.push(row('Pattern regex', 'pattern', 'es: [^0-9]')); extraFields.push(row('Sostituisci con', 'repl', '')); }
                return React.createElement('div', null,
                    hint('Operazione sulla stringa.'),
                    select('Operazione', 'operation', [
                        { value: 'upper',          label: 'MAIUSCOLO' },
                        { value: 'lower',          label: 'minuscolo' },
                        { value: 'trim',           label: 'Rimuovi spazi' },
                        { value: 'replace',        label: 'Sostituisci' },
                        { value: 'substring',      label: 'Sottostringa' },
                        { value: 'pad_left',       label: 'Riempi a sinistra' },
                        { value: 'pad_right',      label: 'Riempi a destra' },
                        { value: 'remove_prefix',  label: 'Rimuovi prefisso' },
                        { value: 'remove_suffix',  label: 'Rimuovi suffisso' },
                        { value: 'regex_replace',  label: 'Regex replace' },
                    ]),
                    ...extraFields
                );
            }

            if (t === 'DEFAULT') return React.createElement('div', null,
                hint('Usa questo valore se il campo sorgente √® vuoto o null.'),
                row('Valore di default', 'value', 'es: EUR oppure 380')
            );

            if (t === 'HARDCODE') return React.createElement('div', null,
                hint('Ignora il valore sorgente e inserisce sempre questo valore fisso.'),
                row('Valore fisso', 'value', 'es: EUR oppure 380 oppure IT')
            );

            if (t === 'COALESCE') return React.createElement('div', null,
                hint('Prende il primo valore non vuoto tra i campi elencati (separati da virgola).'),
                row('Campi alternativi (separati da ,)', 'fields_raw', 'es: VAT_ID, TAX_ID, FISCAL_CODE')
            );

            if (t === 'SUM_MULTI') return React.createElement('div', null,
                hint('Somma numericamente pi√π campi sorgente. Usa multi-source per selezionare i campi.'),
                row('Decimali', 'decimals', '2', 'number')
            );

            if (t === 'CUSTOM') return React.createElement('div', { style: { fontSize: '12px', color: '#888', padding: '8px 0' } },
                '‚úèÔ∏è Clicca "Apri Editor Avanzato" per scrivere l\'espressione Python.'
            );

            return React.createElement('div', { style: { fontSize: '12px', color: '#888', padding: '8px 0' } },
                'Seleziona una formula per vedere i parametri.'
            );
        }

        function PropertiesPanel({ connection, updateConnectionTransformation, deleteConnection, setSelectedConnection, setShowFormulaEditor, setEditingConnection, availableFormulas }) {
            const [transType, setTransType] = useState(connection.transformation?.type || 'direct');
            const [params, setParams] = useState(connection.transformation?.params || {});

            const saveParams = (newParams) => {
                setParams(newParams);
                updateConnectionTransformation(connection.id, { type: transType, params: newParams });
            };

            const handleTypeChange = (newType) => {
                setTransType(newType);
                setParams({});
                updateConnectionTransformation(connection.id, { type: newType, params: {} });
            };

            const sectionStyle = { background: '#f5f9ff', border: '1px solid #e3eaf5', borderRadius: '6px', padding: '12px 14px', marginTop: '12px' };
            const sectionLabel = { fontSize: '11px', fontWeight: '700', color: '#29D6EC', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '10px' };

            // Build formula options
            const STATIC_FORMULAS = [
                { id: 'direct',      label: '‚Üí Direct (1:1)' },
                { id: 'custom',      label: '‚úèÔ∏è Custom Formula' },
                { id: 'concat',      label: 'üîó Concatenate' },
                { id: 'split',       label: '‚úÇÔ∏è Split' },
                { id: 'date_format', label: 'üìÖ Date Format' },
                { id: 'math',        label: 'üî¢ Math' },
                { id: 'lookup',      label: 'üìä Lookup Table' },
                { id: 'conditional', label: 'üîÄ Conditional' },
                { id: 'string_op',   label: 'üî§ String Operation' },
                { id: 'default',     label: 'üîÅ Default Value' },
                { id: 'hardcode',    label: 'üìå Hardcode' },
                { id: 'coalesce',    label: 'üîç Coalesce' },
                { id: 'sum_multi',   label: '‚ûï Sum Multi' },
            ];
            const formulaOptions = (availableFormulas && availableFormulas.length > 0)
                ? [{ id: 'direct', label: '‚Üí Direct (1:1)' }, { id: 'custom', label: '‚úèÔ∏è Custom Formula' },
                   ...availableFormulas.filter(f => !['DIRECT','NOOP'].includes(f.id)).map(f => ({ id: f.id.toLowerCase(), label: f.label }))]
                : STATIC_FORMULAS;

            return React.createElement('div', { className: 'properties-panel' },
                React.createElement('h3', { style: { marginBottom: '16px' } }, '‚öôÔ∏è Connection Properties'),

                // Source / Target
                React.createElement('div', { className: 'form-group' },
                    React.createElement('label', null, 'Source:'),
                    React.createElement('input', { type: 'text', value: connection.sourceName || connection.source, readOnly: true, style: { background: '#f5f5f5', color: '#4caf50', fontWeight: 'bold' } })
                ),
                React.createElement('div', { className: 'form-group' },
                    React.createElement('label', null, 'Target:'),
                    React.createElement('input', { type: 'text', value: connection.targetName || connection.target, readOnly: true, style: { background: '#f5f5f5', color: '#2196f3', fontWeight: 'bold' } })
                ),

                // Formula selector
                React.createElement('div', { className: 'form-group' },
                    React.createElement('label', null, 'Transformation Rule:'),
                    React.createElement('select', {
                        value: transType,
                        onChange: e => handleTypeChange(e.target.value),
                        style: { fontWeight: '600' }
                    }, formulaOptions.map(f => React.createElement('option', { key: f.id, value: f.id }, f.label)))
                ),

                // Params panel
                transType !== 'direct' && React.createElement('div', { style: sectionStyle },
                    React.createElement('div', { style: sectionLabel }, '‚öôÔ∏è Parametri'),
                    React.createElement(FormulaParamsPanel, { transType, params, onChange: saveParams })
                ),

                // Custom formula button
                (transType === 'custom' || transType === 'CUSTOM') && React.createElement('button', {
                    className: 'btn btn-primary',
                    style: { width: '100%', marginTop: '12px' },
                    onClick: () => { setEditingConnection(connection); setShowFormulaEditor(true); }
                }, '‚úèÔ∏è Apri Editor Avanzato'),

                // Delete / Close
                React.createElement('div', { style: { display: 'flex', gap: '10px', marginTop: '24px' } },
                    React.createElement('button', { className: 'btn btn-danger', style: { flex: 1 }, onClick: () => deleteConnection(connection.id) }, 'üóëÔ∏è Delete'),
                    React.createElement('button', { className: 'btn btn-secondary', style: { flex: 1 }, onClick: () => setSelectedConnection(null) }, '‚úï Close')
                )
            );
        }
        
        function UploadModal({ direction, onClose, onUpload }) {
            const [file, setFile] = useState(null);
            const [type, setType] = useState('csv');
            const [isDragging, setIsDragging] = useState(false);
            const fileInputRef = useRef(null);
            
            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            };
            
            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
            };
            
            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
                
                const droppedFile = e.dataTransfer.files[0];
                if (droppedFile) {
                    setFile(droppedFile);
                }
            };
            
            return React.createElement('div', { className: 'modal-overlay', onClick: onClose },
                React.createElement('div', { className: 'modal', onClick: (e) => e.stopPropagation() },
                    React.createElement('h3', { style: { marginBottom: '20px' } }, `Upload ${direction} Schema`),
                    React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Schema Type:'),
                        React.createElement('select', {
                            value: type,
                            onChange: (e) => setType(e.target.value)
                        },
                            React.createElement('option', { value: 'csv' }, 'üìä CSV (Recommended)'),
                            React.createElement('option', { value: 'xsd' }, 'üìÑ XSD'),
                            React.createElement('option', { value: 'idoc' }, 'üìä IDOC')
                        )
                    ),
                    React.createElement('div', {
                        className: 'upload-area',
                        onClick: () => fileInputRef.current?.click(),
                        onDragOver: handleDragOver,
                        onDragLeave: handleDragLeave,
                        onDrop: handleDrop,
                        style: {
                            border: isDragging ? '3px dashed #00BCD4' : '2px dashed #ddd',
                            background: isDragging ? '#f0f4ff' : 'transparent'
                        }
                    },
                        file ? React.createElement('div', null,
                            React.createElement('div', { style: { fontSize: '48px' } }, '‚úÖ'),
                            React.createElement('div', { style: { fontWeight: 'bold' } }, file.name)
                        ) : React.createElement('div', null,
                            React.createElement('div', { style: { fontSize: '64px' } }, isDragging ? 'üìÇ' : 'üìÅ'),
                            React.createElement('div', null, isDragging ? 'Drop file here' : 'Click or drag file here')
                        ),
                        React.createElement('input', {
                            ref: fileInputRef,
                            type: 'file',
                            style: { display: 'none' },
                            onChange: (e) => setFile(e.target.files[0]),
                            accept: '.csv,.xsd,.json,.xml,.txt'
                        })
                    ),
                    React.createElement('div', { style: { display: 'flex', gap: '10px', marginTop: '20px', justifyContent: 'flex-end' } },
                        React.createElement('button', { className: 'btn btn-secondary', onClick: onClose }, 'Cancel'),
                        React.createElement('button', {
                            className: 'btn btn-primary',
                            onClick: () => file && onUpload(file, direction, type),
                            disabled: !file
                        }, 'Upload')
                    )
                )
            );
        }
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
